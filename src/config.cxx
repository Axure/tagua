// Copyright (C) 2005-2006 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// In addition, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "config.hxx"

// Configuration
// 

const Configuration::general::type& Configuration::
general () const
{
  return this->_xsd_general_.get ();
}

Configuration::general::type& Configuration::
general ()
{
  return this->_xsd_general_.get ();
}

void Configuration::
general (const general::type& general)
{
  this->_xsd_general_.set (general);
}

void Configuration::
general (::std::auto_ptr< general::type > general)
{
  this->_xsd_general_.set (general);
}

const Configuration::animations::type& Configuration::
animations () const
{
  return this->_xsd_animations_.get ();
}

Configuration::animations::type& Configuration::
animations ()
{
  return this->_xsd_animations_.get ();
}

void Configuration::
animations (const animations::type& animations)
{
  this->_xsd_animations_.set (animations);
}

void Configuration::
animations (::std::auto_ptr< animations::type > animations)
{
  this->_xsd_animations_.set (animations);
}

const Configuration::board_border::type& Configuration::
board_border () const
{
  return this->_xsd_board_border_.get ();
}

Configuration::board_border::type& Configuration::
board_border ()
{
  return this->_xsd_board_border_.get ();
}

void Configuration::
board_border (const board_border::type& board_border)
{
  this->_xsd_board_border_.set (board_border);
}

void Configuration::
board_border (::std::auto_ptr< board_border::type > board_border)
{
  this->_xsd_board_border_.set (board_border);
}

const Configuration::ics::type& Configuration::
ics () const
{
  return this->_xsd_ics_.get ();
}

Configuration::ics::type& Configuration::
ics ()
{
  return this->_xsd_ics_.get ();
}

void Configuration::
ics (const ics::type& ics)
{
  this->_xsd_ics_.set (ics);
}

void Configuration::
ics (::std::auto_ptr< ics::type > ics)
{
  this->_xsd_ics_.set (ics);
}

const Configuration::clock::type& Configuration::
clock () const
{
  return this->_xsd_clock_.get ();
}

Configuration::clock::type& Configuration::
clock ()
{
  return this->_xsd_clock_.get ();
}

void Configuration::
clock (const clock::type& clock)
{
  this->_xsd_clock_.set (clock);
}

void Configuration::
clock (::std::auto_ptr< clock::type > clock)
{
  this->_xsd_clock_.set (clock);
}

const Configuration::highlighting::type& Configuration::
highlighting () const
{
  return this->_xsd_highlighting_.get ();
}

Configuration::highlighting::type& Configuration::
highlighting ()
{
  return this->_xsd_highlighting_.get ();
}

void Configuration::
highlighting (const highlighting::type& highlighting)
{
  this->_xsd_highlighting_.set (highlighting);
}

void Configuration::
highlighting (::std::auto_ptr< highlighting::type > highlighting)
{
  this->_xsd_highlighting_.set (highlighting);
}

const Configuration::movelist::type& Configuration::
movelist () const
{
  return this->_xsd_movelist_.get ();
}

Configuration::movelist::type& Configuration::
movelist ()
{
  return this->_xsd_movelist_.get ();
}

void Configuration::
movelist (const movelist::type& movelist)
{
  this->_xsd_movelist_.set (movelist);
}

void Configuration::
movelist (::std::auto_ptr< movelist::type > movelist)
{
  this->_xsd_movelist_.set (movelist);
}

const Configuration::variants::type& Configuration::
variants () const
{
  return this->_xsd_variants_.get ();
}

Configuration::variants::type& Configuration::
variants ()
{
  return this->_xsd_variants_.get ();
}

void Configuration::
variants (const variants::type& variants)
{
  this->_xsd_variants_.set (variants);
}

void Configuration::
variants (::std::auto_ptr< variants::type > variants)
{
  this->_xsd_variants_.set (variants);
}

const Configuration::engines::type& Configuration::
engines () const
{
  return this->_xsd_engines_.get ();
}

Configuration::engines::type& Configuration::
engines ()
{
  return this->_xsd_engines_.get ();
}

void Configuration::
engines (const engines::type& engines)
{
  this->_xsd_engines_.set (engines);
}

void Configuration::
engines (::std::auto_ptr< engines::type > engines)
{
  this->_xsd_engines_.set (engines);
}


// General
// 

const General::data_dir::type& General::
data_dir () const
{
  return this->_xsd_data_dir_.get ();
}

General::data_dir::type& General::
data_dir ()
{
  return this->_xsd_data_dir_.get ();
}

void General::
data_dir (const data_dir::type& data_dir)
{
  this->_xsd_data_dir_.set (data_dir);
}

void General::
data_dir (::std::auto_ptr< data_dir::type > data_dir)
{
  this->_xsd_data_dir_.set (data_dir);
}


// BoardBorderConfiguration
// 

const BoardBorderConfiguration::visible::type& BoardBorderConfiguration::
visible () const
{
  return this->_xsd_visible_.get ();
}

BoardBorderConfiguration::visible::type& BoardBorderConfiguration::
visible ()
{
  return this->_xsd_visible_.get ();
}

void BoardBorderConfiguration::
visible (const visible::type& visible)
{
  this->_xsd_visible_.set (visible);
}

void BoardBorderConfiguration::
visible (::std::auto_ptr< visible::type > visible)
{
  this->_xsd_visible_.set (visible);
}

const BoardBorderConfiguration::color::type& BoardBorderConfiguration::
color () const
{
  return this->_xsd_color_.get ();
}

BoardBorderConfiguration::color::type& BoardBorderConfiguration::
color ()
{
  return this->_xsd_color_.get ();
}

void BoardBorderConfiguration::
color (const color::type& color)
{
  this->_xsd_color_.set (color);
}

void BoardBorderConfiguration::
color (::std::auto_ptr< color::type > color)
{
  this->_xsd_color_.set (color);
}

const BoardBorderConfiguration::font::type& BoardBorderConfiguration::
font () const
{
  return this->_xsd_font_.get ();
}

BoardBorderConfiguration::font::type& BoardBorderConfiguration::
font ()
{
  return this->_xsd_font_.get ();
}

void BoardBorderConfiguration::
font (const font::type& font)
{
  this->_xsd_font_.set (font);
}

void BoardBorderConfiguration::
font (::std::auto_ptr< font::type > font)
{
  this->_xsd_font_.set (font);
}

const BoardBorderConfiguration::text_color::type& BoardBorderConfiguration::
text_color () const
{
  return this->_xsd_text_color_.get ();
}

BoardBorderConfiguration::text_color::type& BoardBorderConfiguration::
text_color ()
{
  return this->_xsd_text_color_.get ();
}

void BoardBorderConfiguration::
text_color (const text_color::type& text_color)
{
  this->_xsd_text_color_.set (text_color);
}

void BoardBorderConfiguration::
text_color (::std::auto_ptr< text_color::type > text_color)
{
  this->_xsd_text_color_.set (text_color);
}


// IcsConfiguration
// 

const IcsConfiguration::username::type& IcsConfiguration::
username () const
{
  return this->_xsd_username_.get ();
}

IcsConfiguration::username::type& IcsConfiguration::
username ()
{
  return this->_xsd_username_.get ();
}

void IcsConfiguration::
username (const username::type& username)
{
  this->_xsd_username_.set (username);
}

void IcsConfiguration::
username (::std::auto_ptr< username::type > username)
{
  this->_xsd_username_.set (username);
}

const IcsConfiguration::password::type& IcsConfiguration::
password () const
{
  return this->_xsd_password_.get ();
}

IcsConfiguration::password::type& IcsConfiguration::
password ()
{
  return this->_xsd_password_.get ();
}

void IcsConfiguration::
password (const password::type& password)
{
  this->_xsd_password_.set (password);
}

void IcsConfiguration::
password (::std::auto_ptr< password::type > password)
{
  this->_xsd_password_.set (password);
}

const IcsConfiguration::host::type& IcsConfiguration::
host () const
{
  return this->_xsd_host_.get ();
}

IcsConfiguration::host::type& IcsConfiguration::
host ()
{
  return this->_xsd_host_.get ();
}

void IcsConfiguration::
host (const host::type& host)
{
  this->_xsd_host_.set (host);
}

void IcsConfiguration::
host (::std::auto_ptr< host::type > host)
{
  this->_xsd_host_.set (host);
}

const IcsConfiguration::port::type& IcsConfiguration::
port () const
{
  return this->_xsd_port_.get ();
}

IcsConfiguration::port::type& IcsConfiguration::
port ()
{
  return this->_xsd_port_.get ();
}

void IcsConfiguration::
port (const port::type& port)
{
  this->_xsd_port_.set (port);
}

const IcsConfiguration::timeseal::type& IcsConfiguration::
timeseal () const
{
  return this->_xsd_timeseal_.get ();
}

IcsConfiguration::timeseal::type& IcsConfiguration::
timeseal ()
{
  return this->_xsd_timeseal_.get ();
}

void IcsConfiguration::
timeseal (const timeseal::type& timeseal)
{
  this->_xsd_timeseal_.set (timeseal);
}

void IcsConfiguration::
timeseal (::std::auto_ptr< timeseal::type > timeseal)
{
  this->_xsd_timeseal_.set (timeseal);
}


// Timeseal
// 

const Timeseal::command::type& Timeseal::
command () const
{
  return this->_xsd_command_.get ();
}

Timeseal::command::type& Timeseal::
command ()
{
  return this->_xsd_command_.get ();
}

void Timeseal::
command (const command::type& command)
{
  this->_xsd_command_.set (command);
}

void Timeseal::
command (::std::auto_ptr< command::type > command)
{
  this->_xsd_command_.set (command);
}

const Timeseal::path::type& Timeseal::
path () const
{
  return this->_xsd_path_.get ();
}

Timeseal::path::type& Timeseal::
path ()
{
  return this->_xsd_path_.get ();
}

void Timeseal::
path (const path::type& path)
{
  this->_xsd_path_.set (path);
}

void Timeseal::
path (::std::auto_ptr< path::type > path)
{
  this->_xsd_path_.set (path);
}

const Timeseal::use::type& Timeseal::use::
default_value ()
{
  return default_value_;
}

const Timeseal::use::type& Timeseal::
use () const
{
  return this->_xsd_use_.get ();
}

Timeseal::use::type& Timeseal::
use ()
{
  return this->_xsd_use_.get ();
}

void Timeseal::
use (const use::type& use)
{
  this->_xsd_use_.set (use);
}


// TimesealCommand
// 

const TimesealCommand::use::type& TimesealCommand::use::
default_value ()
{
  return default_value_;
}

const TimesealCommand::use::type& TimesealCommand::
use () const
{
  return this->_xsd_use_.get ();
}

TimesealCommand::use::type& TimesealCommand::
use ()
{
  return this->_xsd_use_.get ();
}

void TimesealCommand::
use (const use::type& use)
{
  this->_xsd_use_.set (use);
}


// ClockConfiguration
// 

const ClockConfiguration::background_color::type& ClockConfiguration::
background_color () const
{
  return this->_xsd_background_color_.get ();
}

ClockConfiguration::background_color::type& ClockConfiguration::
background_color ()
{
  return this->_xsd_background_color_.get ();
}

void ClockConfiguration::
background_color (const background_color::type& background_color)
{
  this->_xsd_background_color_.set (background_color);
}

void ClockConfiguration::
background_color (::std::auto_ptr< background_color::type > background_color)
{
  this->_xsd_background_color_.set (background_color);
}

const ClockConfiguration::caption::type& ClockConfiguration::
caption () const
{
  return this->_xsd_caption_.get ();
}

ClockConfiguration::caption::type& ClockConfiguration::
caption ()
{
  return this->_xsd_caption_.get ();
}

void ClockConfiguration::
caption (const caption::type& caption)
{
  this->_xsd_caption_.set (caption);
}

void ClockConfiguration::
caption (::std::auto_ptr< caption::type > caption)
{
  this->_xsd_caption_.set (caption);
}

const ClockConfiguration::decimals::type& ClockConfiguration::
decimals () const
{
  return this->_xsd_decimals_.get ();
}

ClockConfiguration::decimals::type& ClockConfiguration::
decimals ()
{
  return this->_xsd_decimals_.get ();
}

void ClockConfiguration::
decimals (const decimals::type& decimals)
{
  this->_xsd_decimals_.set (decimals);
}

void ClockConfiguration::
decimals (::std::auto_ptr< decimals::type > decimals)
{
  this->_xsd_decimals_.set (decimals);
}

const ClockConfiguration::player::type& ClockConfiguration::
player () const
{
  return this->_xsd_player_.get ();
}

ClockConfiguration::player::type& ClockConfiguration::
player ()
{
  return this->_xsd_player_.get ();
}

void ClockConfiguration::
player (const player::type& player)
{
  this->_xsd_player_.set (player);
}

void ClockConfiguration::
player (::std::auto_ptr< player::type > player)
{
  this->_xsd_player_.set (player);
}

const ClockConfiguration::time::type& ClockConfiguration::
time () const
{
  return this->_xsd_time_.get ();
}

ClockConfiguration::time::type& ClockConfiguration::
time ()
{
  return this->_xsd_time_.get ();
}

void ClockConfiguration::
time (const time::type& time)
{
  this->_xsd_time_.set (time);
}

void ClockConfiguration::
time (::std::auto_ptr< time::type > time)
{
  this->_xsd_time_.set (time);
}


// ClockElement
// 

const ClockElement::size::type& ClockElement::
size () const
{
  return this->_xsd_size_.get ();
}

ClockElement::size::type& ClockElement::
size ()
{
  return this->_xsd_size_.get ();
}

void ClockElement::
size (const size::type& size)
{
  this->_xsd_size_.set (size);
}


// HighlightingConfiguration
// 

const HighlightingConfiguration::lua::type& HighlightingConfiguration::
lua () const
{
  return this->_xsd_lua_.get ();
}

HighlightingConfiguration::lua::type& HighlightingConfiguration::
lua ()
{
  return this->_xsd_lua_.get ();
}

void HighlightingConfiguration::
lua (const lua::type& lua)
{
  this->_xsd_lua_.set (lua);
}

void HighlightingConfiguration::
lua (::std::auto_ptr< lua::type > lua)
{
  this->_xsd_lua_.set (lua);
}

const HighlightingConfiguration::simple_highlighting::type& HighlightingConfiguration::
simple_highlighting () const
{
  return this->_xsd_simple_highlighting_.get ();
}

HighlightingConfiguration::simple_highlighting::type& HighlightingConfiguration::
simple_highlighting ()
{
  return this->_xsd_simple_highlighting_.get ();
}

void HighlightingConfiguration::
simple_highlighting (const simple_highlighting::type& simple_highlighting)
{
  this->_xsd_simple_highlighting_.set (simple_highlighting);
}

void HighlightingConfiguration::
simple_highlighting (::std::auto_ptr< simple_highlighting::type > simple_highlighting)
{
  this->_xsd_simple_highlighting_.set (simple_highlighting);
}


// LuaHLConfiguration
// 

const LuaHLConfiguration::library_path::type& LuaHLConfiguration::
library_path () const
{
  return this->_xsd_library_path_.get ();
}

LuaHLConfiguration::library_path::type& LuaHLConfiguration::
library_path ()
{
  return this->_xsd_library_path_.get ();
}

void LuaHLConfiguration::
library_path (const library_path::type& library_path)
{
  this->_xsd_library_path_.set (library_path);
}

void LuaHLConfiguration::
library_path (::std::auto_ptr< library_path::type > library_path)
{
  this->_xsd_library_path_.set (library_path);
}

const LuaHLConfiguration::scripts::type& LuaHLConfiguration::
scripts () const
{
  return this->_xsd_scripts_.get ();
}

LuaHLConfiguration::scripts::type& LuaHLConfiguration::
scripts ()
{
  return this->_xsd_scripts_.get ();
}

void LuaHLConfiguration::
scripts (const scripts::type& scripts)
{
  this->_xsd_scripts_.set (scripts);
}

void LuaHLConfiguration::
scripts (::std::auto_ptr< scripts::type > scripts)
{
  this->_xsd_scripts_.set (scripts);
}

const LuaHLConfiguration::use::type& LuaHLConfiguration::use::
default_value ()
{
  return default_value_;
}

const LuaHLConfiguration::use::type& LuaHLConfiguration::
use () const
{
  return this->_xsd_use_.get ();
}

LuaHLConfiguration::use::type& LuaHLConfiguration::
use ()
{
  return this->_xsd_use_.get ();
}

void LuaHLConfiguration::
use (const use::type& use)
{
  this->_xsd_use_.set (use);
}


// ScriptList
// 

const ScriptList::script::container& ScriptList::
script () const
{
  return this->_xsd_script_;
}

ScriptList::script::container& ScriptList::
script ()
{
  return this->_xsd_script_;
}

void ScriptList::
script (const script::container& script)
{
  this->_xsd_script_ = script;
}


// SimpleHighlighting
// 

const SimpleHighlighting::pattern::container& SimpleHighlighting::
pattern () const
{
  return this->_xsd_pattern_;
}

SimpleHighlighting::pattern::container& SimpleHighlighting::
pattern ()
{
  return this->_xsd_pattern_;
}

void SimpleHighlighting::
pattern (const pattern::container& pattern)
{
  this->_xsd_pattern_ = pattern;
}


// HighlightingPattern
// 

const HighlightingPattern::name::type& HighlightingPattern::
name () const
{
  return this->_xsd_name_.get ();
}

HighlightingPattern::name::type& HighlightingPattern::
name ()
{
  return this->_xsd_name_.get ();
}

void HighlightingPattern::
name (const name::type& name)
{
  this->_xsd_name_.set (name);
}

void HighlightingPattern::
name (::std::auto_ptr< name::type > name)
{
  this->_xsd_name_.set (name);
}

const HighlightingPattern::regexp::type& HighlightingPattern::
regexp () const
{
  return this->_xsd_regexp_.get ();
}

HighlightingPattern::regexp::type& HighlightingPattern::
regexp ()
{
  return this->_xsd_regexp_.get ();
}

void HighlightingPattern::
regexp (const regexp::type& regexp)
{
  this->_xsd_regexp_.set (regexp);
}

void HighlightingPattern::
regexp (::std::auto_ptr< regexp::type > regexp)
{
  this->_xsd_regexp_.set (regexp);
}

const HighlightingPattern::format::type& HighlightingPattern::
format () const
{
  return this->_xsd_format_.get ();
}

HighlightingPattern::format::type& HighlightingPattern::
format ()
{
  return this->_xsd_format_.get ();
}

void HighlightingPattern::
format (const format::type& format)
{
  this->_xsd_format_.set (format);
}

void HighlightingPattern::
format (::std::auto_ptr< format::type > format)
{
  this->_xsd_format_.set (format);
}


// HighlightingFormat
// 

const HighlightingFormat::bold::container& HighlightingFormat::
bold () const
{
  return this->_xsd_bold_;
}

HighlightingFormat::bold::container& HighlightingFormat::
bold ()
{
  return this->_xsd_bold_;
}

void HighlightingFormat::
bold (const bold::type& bold)
{
  this->_xsd_bold_.set (bold);
}

void HighlightingFormat::
bold (const bold::container& bold)
{
  this->_xsd_bold_ = bold;
}

const HighlightingFormat::italic::container& HighlightingFormat::
italic () const
{
  return this->_xsd_italic_;
}

HighlightingFormat::italic::container& HighlightingFormat::
italic ()
{
  return this->_xsd_italic_;
}

void HighlightingFormat::
italic (const italic::type& italic)
{
  this->_xsd_italic_.set (italic);
}

void HighlightingFormat::
italic (const italic::container& italic)
{
  this->_xsd_italic_ = italic;
}

const HighlightingFormat::color::container& HighlightingFormat::
color () const
{
  return this->_xsd_color_;
}

HighlightingFormat::color::container& HighlightingFormat::
color ()
{
  return this->_xsd_color_;
}

void HighlightingFormat::
color (const color::type& color)
{
  this->_xsd_color_.set (color);
}

void HighlightingFormat::
color (const color::container& color)
{
  this->_xsd_color_ = color;
}

void HighlightingFormat::
color (::std::auto_ptr< color::type > color)
{
  this->_xsd_color_.set (color);
}


// MovelistConfiguration
// 

const MovelistConfiguration::animations::type& MovelistConfiguration::
animations () const
{
  return this->_xsd_animations_.get ();
}

MovelistConfiguration::animations::type& MovelistConfiguration::
animations ()
{
  return this->_xsd_animations_.get ();
}

void MovelistConfiguration::
animations (const animations::type& animations)
{
  this->_xsd_animations_.set (animations);
}

void MovelistConfiguration::
animations (::std::auto_ptr< animations::type > animations)
{
  this->_xsd_animations_.set (animations);
}

const MovelistConfiguration::comments::type& MovelistConfiguration::
comments () const
{
  return this->_xsd_comments_.get ();
}

MovelistConfiguration::comments::type& MovelistConfiguration::
comments ()
{
  return this->_xsd_comments_.get ();
}

void MovelistConfiguration::
comments (const comments::type& comments)
{
  this->_xsd_comments_.set (comments);
}

void MovelistConfiguration::
comments (::std::auto_ptr< comments::type > comments)
{
  this->_xsd_comments_.set (comments);
}

const MovelistConfiguration::selection_color::type& MovelistConfiguration::
selection_color () const
{
  return this->_xsd_selection_color_.get ();
}

MovelistConfiguration::selection_color::type& MovelistConfiguration::
selection_color ()
{
  return this->_xsd_selection_color_.get ();
}

void MovelistConfiguration::
selection_color (const selection_color::type& selection_color)
{
  this->_xsd_selection_color_.set (selection_color);
}

void MovelistConfiguration::
selection_color (::std::auto_ptr< selection_color::type > selection_color)
{
  this->_xsd_selection_color_.set (selection_color);
}


// MovelistAnimationConfiguration
// 

const MovelistAnimationConfiguration::speed::type& MovelistAnimationConfiguration::
speed () const
{
  return this->_xsd_speed_.get ();
}

MovelistAnimationConfiguration::speed::type& MovelistAnimationConfiguration::
speed ()
{
  return this->_xsd_speed_.get ();
}

void MovelistAnimationConfiguration::
speed (const speed::type& speed)
{
  this->_xsd_speed_.set (speed);
}

const MovelistAnimationConfiguration::smoothness::type& MovelistAnimationConfiguration::
smoothness () const
{
  return this->_xsd_smoothness_.get ();
}

MovelistAnimationConfiguration::smoothness::type& MovelistAnimationConfiguration::
smoothness ()
{
  return this->_xsd_smoothness_.get ();
}

void MovelistAnimationConfiguration::
smoothness (const smoothness::type& smoothness)
{
  this->_xsd_smoothness_.set (smoothness);
}

const MovelistAnimationConfiguration::animation_list::type& MovelistAnimationConfiguration::
animation_list () const
{
  return this->_xsd_animation_list_.get ();
}

MovelistAnimationConfiguration::animation_list::type& MovelistAnimationConfiguration::
animation_list ()
{
  return this->_xsd_animation_list_.get ();
}

void MovelistAnimationConfiguration::
animation_list (const animation_list::type& animation_list)
{
  this->_xsd_animation_list_.set (animation_list);
}

void MovelistAnimationConfiguration::
animation_list (::std::auto_ptr< animation_list::type > animation_list)
{
  this->_xsd_animation_list_.set (animation_list);
}

const MovelistAnimationConfiguration::enabled::container& MovelistAnimationConfiguration::
enabled () const
{
  return this->_xsd_enabled_;
}

MovelistAnimationConfiguration::enabled::container& MovelistAnimationConfiguration::
enabled ()
{
  return this->_xsd_enabled_;
}

void MovelistAnimationConfiguration::
enabled (const enabled::type& enabled)
{
  this->_xsd_enabled_.set (enabled);
}

void MovelistAnimationConfiguration::
enabled (const enabled::container& enabled)
{
  this->_xsd_enabled_ = enabled;
}


// MovelistAnimationList
// 

const MovelistAnimationList::hide_show::type& MovelistAnimationList::
hide_show () const
{
  return this->_xsd_hide_show_.get ();
}

MovelistAnimationList::hide_show::type& MovelistAnimationList::
hide_show ()
{
  return this->_xsd_hide_show_.get ();
}

void MovelistAnimationList::
hide_show (const hide_show::type& hide_show)
{
  this->_xsd_hide_show_.set (hide_show);
}

void MovelistAnimationList::
hide_show (::std::auto_ptr< hide_show::type > hide_show)
{
  this->_xsd_hide_show_.set (hide_show);
}

const MovelistAnimationList::highlight::type& MovelistAnimationList::
highlight () const
{
  return this->_xsd_highlight_.get ();
}

MovelistAnimationList::highlight::type& MovelistAnimationList::
highlight ()
{
  return this->_xsd_highlight_.get ();
}

void MovelistAnimationList::
highlight (const highlight::type& highlight)
{
  this->_xsd_highlight_.set (highlight);
}

void MovelistAnimationList::
highlight (::std::auto_ptr< highlight::type > highlight)
{
  this->_xsd_highlight_.set (highlight);
}

const MovelistAnimationList::moving::type& MovelistAnimationList::
moving () const
{
  return this->_xsd_moving_.get ();
}

MovelistAnimationList::moving::type& MovelistAnimationList::
moving ()
{
  return this->_xsd_moving_.get ();
}

void MovelistAnimationList::
moving (const moving::type& moving)
{
  this->_xsd_moving_.set (moving);
}

void MovelistAnimationList::
moving (::std::auto_ptr< moving::type > moving)
{
  this->_xsd_moving_.set (moving);
}


// MovelistAnimation
// 

const MovelistAnimation::enabled::type& MovelistAnimation::enabled::
default_value ()
{
  return default_value_;
}

const MovelistAnimation::enabled::type& MovelistAnimation::
enabled () const
{
  return this->_xsd_enabled_.get ();
}

MovelistAnimation::enabled::type& MovelistAnimation::
enabled ()
{
  return this->_xsd_enabled_.get ();
}

void MovelistAnimation::
enabled (const enabled::type& enabled)
{
  this->_xsd_enabled_.set (enabled);
}


// MovelistComments
// 

const MovelistComments::color::type& MovelistComments::
color () const
{
  return this->_xsd_color_.get ();
}

MovelistComments::color::type& MovelistComments::
color ()
{
  return this->_xsd_color_.get ();
}

void MovelistComments::
color (const color::type& color)
{
  this->_xsd_color_.set (color);
}

void MovelistComments::
color (::std::auto_ptr< color::type > color)
{
  this->_xsd_color_.set (color);
}

const MovelistComments::font::type& MovelistComments::
font () const
{
  return this->_xsd_font_.get ();
}

MovelistComments::font::type& MovelistComments::
font ()
{
  return this->_xsd_font_.get ();
}

void MovelistComments::
font (const font::type& font)
{
  this->_xsd_font_.set (font);
}

void MovelistComments::
font (::std::auto_ptr< font::type > font)
{
  this->_xsd_font_.set (font);
}


// VariantConfiguration
// 

const VariantConfiguration::variant::container& VariantConfiguration::
variant () const
{
  return this->_xsd_variant_;
}

VariantConfiguration::variant::container& VariantConfiguration::
variant ()
{
  return this->_xsd_variant_;
}

void VariantConfiguration::
variant (const variant::container& variant)
{
  this->_xsd_variant_ = variant;
}


// Variant
// 

const Variant::name::type& Variant::
name () const
{
  return this->_xsd_name_.get ();
}

Variant::name::type& Variant::
name ()
{
  return this->_xsd_name_.get ();
}

void Variant::
name (const name::type& name)
{
  this->_xsd_name_.set (name);
}

void Variant::
name (::std::auto_ptr< name::type > name)
{
  this->_xsd_name_.set (name);
}

const Variant::theme::type& Variant::
theme () const
{
  return this->_xsd_theme_.get ();
}

Variant::theme::type& Variant::
theme ()
{
  return this->_xsd_theme_.get ();
}

void Variant::
theme (const theme::type& theme)
{
  this->_xsd_theme_.set (theme);
}

void Variant::
theme (::std::auto_ptr< theme::type > theme)
{
  this->_xsd_theme_.set (theme);
}


// VariantTheme
// 

const VariantTheme::pieces::type& VariantTheme::
pieces () const
{
  return this->_xsd_pieces_.get ();
}

VariantTheme::pieces::type& VariantTheme::
pieces ()
{
  return this->_xsd_pieces_.get ();
}

void VariantTheme::
pieces (const pieces::type& pieces)
{
  this->_xsd_pieces_.set (pieces);
}

void VariantTheme::
pieces (::std::auto_ptr< pieces::type > pieces)
{
  this->_xsd_pieces_.set (pieces);
}

const VariantTheme::squares::type& VariantTheme::
squares () const
{
  return this->_xsd_squares_.get ();
}

VariantTheme::squares::type& VariantTheme::
squares ()
{
  return this->_xsd_squares_.get ();
}

void VariantTheme::
squares (const squares::type& squares)
{
  this->_xsd_squares_.set (squares);
}

void VariantTheme::
squares (::std::auto_ptr< squares::type > squares)
{
  this->_xsd_squares_.set (squares);
}

const VariantTheme::inherit_pieces::type& VariantTheme::inherit_pieces::
default_value ()
{
  return default_value_;
}

const VariantTheme::inherit_pieces::type& VariantTheme::
inherit_pieces () const
{
  return this->_xsd_inherit_pieces_.get ();
}

VariantTheme::inherit_pieces::type& VariantTheme::
inherit_pieces ()
{
  return this->_xsd_inherit_pieces_.get ();
}

void VariantTheme::
inherit_pieces (const inherit_pieces::type& inherit_pieces)
{
  this->_xsd_inherit_pieces_.set (inherit_pieces);
}

const VariantTheme::inherit_squares::type& VariantTheme::inherit_squares::
default_value ()
{
  return default_value_;
}

const VariantTheme::inherit_squares::type& VariantTheme::
inherit_squares () const
{
  return this->_xsd_inherit_squares_.get ();
}

VariantTheme::inherit_squares::type& VariantTheme::
inherit_squares ()
{
  return this->_xsd_inherit_squares_.get ();
}

void VariantTheme::
inherit_squares (const inherit_squares::type& inherit_squares)
{
  this->_xsd_inherit_squares_.set (inherit_squares);
}


// AnimationConfiguration
// 

const AnimationConfiguration::smoothness::container& AnimationConfiguration::
smoothness () const
{
  return this->_xsd_smoothness_;
}

AnimationConfiguration::smoothness::container& AnimationConfiguration::
smoothness ()
{
  return this->_xsd_smoothness_;
}

void AnimationConfiguration::
smoothness (const smoothness::type& smoothness)
{
  this->_xsd_smoothness_.set (smoothness);
}

void AnimationConfiguration::
smoothness (const smoothness::container& smoothness)
{
  this->_xsd_smoothness_ = smoothness;
}

const AnimationConfiguration::speed::container& AnimationConfiguration::
speed () const
{
  return this->_xsd_speed_;
}

AnimationConfiguration::speed::container& AnimationConfiguration::
speed ()
{
  return this->_xsd_speed_;
}

void AnimationConfiguration::
speed (const speed::type& speed)
{
  this->_xsd_speed_.set (speed);
}

void AnimationConfiguration::
speed (const speed::container& speed)
{
  this->_xsd_speed_ = speed;
}

const AnimationConfiguration::animation_list::type& AnimationConfiguration::
animation_list () const
{
  return this->_xsd_animation_list_.get ();
}

AnimationConfiguration::animation_list::type& AnimationConfiguration::
animation_list ()
{
  return this->_xsd_animation_list_.get ();
}

void AnimationConfiguration::
animation_list (const animation_list::type& animation_list)
{
  this->_xsd_animation_list_.set (animation_list);
}

void AnimationConfiguration::
animation_list (::std::auto_ptr< animation_list::type > animation_list)
{
  this->_xsd_animation_list_.set (animation_list);
}


// AnimationList
// 

const AnimationList::capture::type& AnimationList::
capture () const
{
  return this->_xsd_capture_.get ();
}

AnimationList::capture::type& AnimationList::
capture ()
{
  return this->_xsd_capture_.get ();
}

void AnimationList::
capture (const capture::type& capture)
{
  this->_xsd_capture_.set (capture);
}

void AnimationList::
capture (::std::auto_ptr< capture::type > capture)
{
  this->_xsd_capture_.set (capture);
}

const AnimationList::fade::type& AnimationList::
fade () const
{
  return this->_xsd_fade_.get ();
}

AnimationList::fade::type& AnimationList::
fade ()
{
  return this->_xsd_fade_.get ();
}

void AnimationList::
fade (const fade::type& fade)
{
  this->_xsd_fade_.set (fade);
}

void AnimationList::
fade (::std::auto_ptr< fade::type > fade)
{
  this->_xsd_fade_.set (fade);
}

const AnimationList::movement::type& AnimationList::
movement () const
{
  return this->_xsd_movement_.get ();
}

AnimationList::movement::type& AnimationList::
movement ()
{
  return this->_xsd_movement_.get ();
}

void AnimationList::
movement (const movement::type& movement)
{
  this->_xsd_movement_.set (movement);
}

void AnimationList::
movement (::std::auto_ptr< movement::type > movement)
{
  this->_xsd_movement_.set (movement);
}

const AnimationList::transform::type& AnimationList::
transform () const
{
  return this->_xsd_transform_.get ();
}

AnimationList::transform::type& AnimationList::
transform ()
{
  return this->_xsd_transform_.get ();
}

void AnimationList::
transform (const transform::type& transform)
{
  this->_xsd_transform_.set (transform);
}

void AnimationList::
transform (::std::auto_ptr< transform::type > transform)
{
  this->_xsd_transform_.set (transform);
}

const AnimationList::sequence::type& AnimationList::
sequence () const
{
  return this->_xsd_sequence_.get ();
}

AnimationList::sequence::type& AnimationList::
sequence ()
{
  return this->_xsd_sequence_.get ();
}

void AnimationList::
sequence (const sequence::type& sequence)
{
  this->_xsd_sequence_.set (sequence);
}

void AnimationList::
sequence (::std::auto_ptr< sequence::type > sequence)
{
  this->_xsd_sequence_.set (sequence);
}


// Animation
// 

const Animation::enabled::container& Animation::
enabled () const
{
  return this->_xsd_enabled_;
}

Animation::enabled::container& Animation::
enabled ()
{
  return this->_xsd_enabled_;
}

void Animation::
enabled (const enabled::type& enabled)
{
  this->_xsd_enabled_.set (enabled);
}

void Animation::
enabled (const enabled::container& enabled)
{
  this->_xsd_enabled_ = enabled;
}


// SequenceAnimation
// 

const SequenceAnimation::max::type& SequenceAnimation::
max () const
{
  return this->_xsd_max_.get ();
}

SequenceAnimation::max::type& SequenceAnimation::
max ()
{
  return this->_xsd_max_.get ();
}

void SequenceAnimation::
max (const max::type& max)
{
  this->_xsd_max_.set (max);
}


// EngineConfiguration
// 

const EngineConfiguration::default_::container& EngineConfiguration::
default_ () const
{
  return this->_xsd_default__;
}

EngineConfiguration::default_::container& EngineConfiguration::
default_ ()
{
  return this->_xsd_default__;
}

void EngineConfiguration::
default_ (const default_::type& default_)
{
  this->_xsd_default__.set (default_);
}

void EngineConfiguration::
default_ (const default_::container& default_)
{
  this->_xsd_default__ = default_;
}

const EngineConfiguration::engine_list::type& EngineConfiguration::
engine_list () const
{
  return this->_xsd_engine_list_.get ();
}

EngineConfiguration::engine_list::type& EngineConfiguration::
engine_list ()
{
  return this->_xsd_engine_list_.get ();
}

void EngineConfiguration::
engine_list (const engine_list::type& engine_list)
{
  this->_xsd_engine_list_.set (engine_list);
}

void EngineConfiguration::
engine_list (::std::auto_ptr< engine_list::type > engine_list)
{
  this->_xsd_engine_list_.set (engine_list);
}


// EngineList
// 

const EngineList::engine::container& EngineList::
engine () const
{
  return this->_xsd_engine_;
}

EngineList::engine::container& EngineList::
engine ()
{
  return this->_xsd_engine_;
}

void EngineList::
engine (const engine::container& engine)
{
  this->_xsd_engine_ = engine;
}


// Engine
// 

const Engine::name::type& Engine::
name () const
{
  return this->_xsd_name_.get ();
}

Engine::name::type& Engine::
name ()
{
  return this->_xsd_name_.get ();
}

void Engine::
name (const name::type& name)
{
  this->_xsd_name_.set (name);
}

void Engine::
name (::std::auto_ptr< name::type > name)
{
  this->_xsd_name_.set (name);
}

const Engine::path::type& Engine::
path () const
{
  return this->_xsd_path_.get ();
}

Engine::path::type& Engine::
path ()
{
  return this->_xsd_path_.get ();
}

void Engine::
path (const path::type& path)
{
  this->_xsd_path_.set (path);
}

void Engine::
path (::std::auto_ptr< path::type > path)
{
  this->_xsd_path_.set (path);
}

const Engine::type::container& Engine::
type () const
{
  return this->_xsd_type_;
}

Engine::type::container& Engine::
type ()
{
  return this->_xsd_type_;
}

void Engine::
type (const type::type_& type)
{
  this->_xsd_type_.set (type);
}

void Engine::
type (const type::container& type)
{
  this->_xsd_type_ = type;
}

void Engine::
type (::std::auto_ptr< type::type_ > type)
{
  this->_xsd_type_.set (type);
}


// EngineType
// 

EngineType::
EngineType (_xsd_EngineType v)
: ::xml_schema::string (_xsd_EngineType_literals_[v])
{
}

EngineType::
EngineType (const ::xml_schema::string& _xsd_EngineType)
: ::xml_schema::string (_xsd_EngineType)
{
}

EngineType::
EngineType (const EngineType& v,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::string (v, f, c)
{
}

EngineType& EngineType::
operator= (_xsd_EngineType v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_EngineType_literals_[v]);

  return *this;
}


#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/parser.hxx>

// Configuration
//

Configuration::
Configuration (const general::type& _xsd_general,
               const animations::type& _xsd_animations,
               const board_border::type& _xsd_board_border,
               const ics::type& _xsd_ics,
               const clock::type& _xsd_clock,
               const highlighting::type& _xsd_highlighting,
               const movelist::type& _xsd_movelist,
               const variants::type& _xsd_variants,
               const engines::type& _xsd_engines)
: ::xml_schema::type (),
_xsd_general_ (_xsd_general,
               ::xml_schema::flags (),
               this),
_xsd_animations_ (_xsd_animations,
                  ::xml_schema::flags (),
                  this),
_xsd_board_border_ (_xsd_board_border,
                    ::xml_schema::flags (),
                    this),
_xsd_ics_ (_xsd_ics,
           ::xml_schema::flags (),
           this),
_xsd_clock_ (_xsd_clock,
             ::xml_schema::flags (),
             this),
_xsd_highlighting_ (_xsd_highlighting,
                    ::xml_schema::flags (),
                    this),
_xsd_movelist_ (_xsd_movelist,
                ::xml_schema::flags (),
                this),
_xsd_variants_ (_xsd_variants,
                ::xml_schema::flags (),
                this),
_xsd_engines_ (_xsd_engines,
               ::xml_schema::flags (),
               this)
{
}

Configuration::
Configuration (const Configuration& _xsd_Configuration,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::type (_xsd_Configuration, f, c),
_xsd_general_ (_xsd_Configuration._xsd_general_,
               f | ::xml_schema::flags::not_root,
               this),
_xsd_animations_ (_xsd_Configuration._xsd_animations_,
                  f | ::xml_schema::flags::not_root,
                  this),
_xsd_board_border_ (_xsd_Configuration._xsd_board_border_,
                    f | ::xml_schema::flags::not_root,
                    this),
_xsd_ics_ (_xsd_Configuration._xsd_ics_,
           f | ::xml_schema::flags::not_root,
           this),
_xsd_clock_ (_xsd_Configuration._xsd_clock_,
             f | ::xml_schema::flags::not_root,
             this),
_xsd_highlighting_ (_xsd_Configuration._xsd_highlighting_,
                    f | ::xml_schema::flags::not_root,
                    this),
_xsd_movelist_ (_xsd_Configuration._xsd_movelist_,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_variants_ (_xsd_Configuration._xsd_variants_,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_engines_ (_xsd_Configuration._xsd_engines_,
               f | ::xml_schema::flags::not_root,
               this)
{
}

Configuration::
Configuration (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_general_ (f | ::xml_schema::flags::not_root, this),
_xsd_animations_ (f | ::xml_schema::flags::not_root, this),
_xsd_board_border_ (f | ::xml_schema::flags::not_root, this),
_xsd_ics_ (f | ::xml_schema::flags::not_root, this),
_xsd_clock_ (f | ::xml_schema::flags::not_root, this),
_xsd_highlighting_ (f | ::xml_schema::flags::not_root, this),
_xsd_movelist_ (f | ::xml_schema::flags::not_root, this),
_xsd_variants_ (f | ::xml_schema::flags::not_root, this),
_xsd_engines_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void Configuration::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // general
    //
    {
      if (e.name () == "general" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< general::type > r (
          general::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_general_.present ())
          continue;
        this->general (r);
        continue;
      }
    }

    // animations
    //
    {
      if (e.name () == "animations" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< animations::type > r (
          animations::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_animations_.present ())
          continue;
        this->animations (r);
        continue;
      }
    }

    // board_border
    //
    {
      if (e.name () == "board-border" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< board_border::type > r (
          board_border::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_board_border_.present ())
          continue;
        this->board_border (r);
        continue;
      }
    }

    // ics
    //
    {
      if (e.name () == "ics" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< ics::type > r (
          ics::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_ics_.present ())
          continue;
        this->ics (r);
        continue;
      }
    }

    // clock
    //
    {
      if (e.name () == "clock" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< clock::type > r (
          clock::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_clock_.present ())
          continue;
        this->clock (r);
        continue;
      }
    }

    // highlighting
    //
    {
      if (e.name () == "highlighting" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< highlighting::type > r (
          highlighting::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_highlighting_.present ())
          continue;
        this->highlighting (r);
        continue;
      }
    }

    // movelist
    //
    {
      if (e.name () == "movelist" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< movelist::type > r (
          movelist::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_movelist_.present ())
          continue;
        this->movelist (r);
        continue;
      }
    }

    // variants
    //
    {
      if (e.name () == "variants" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< variants::type > r (
          variants::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_variants_.present ())
          continue;
        this->variants (r);
        continue;
      }
    }

    // engines
    //
    {
      if (e.name () == "engines" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< engines::type > r (
          engines::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_engines_.present ())
          continue;
        this->engines (r);
        continue;
      }
    }
  }

  if (!_xsd_general_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "general",
      "");
  }

  if (!_xsd_animations_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "animations",
      "");
  }

  if (!_xsd_board_border_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "board-border",
      "");
  }

  if (!_xsd_ics_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ics",
      "");
  }

  if (!_xsd_clock_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "clock",
      "");
  }

  if (!_xsd_highlighting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "highlighting",
      "");
  }

  if (!_xsd_movelist_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "movelist",
      "");
  }

  if (!_xsd_variants_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "variants",
      "");
  }

  if (!_xsd_engines_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "engines",
      "");
  }
}

Configuration* Configuration::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new Configuration (*this, f, c);
}

// General
//

General::
General (const data_dir::type& _xsd_data_dir)
: ::xml_schema::type (),
_xsd_data_dir_ (_xsd_data_dir,
                ::xml_schema::flags (),
                this)
{
}

General::
General (const General& _xsd_General,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
: ::xml_schema::type (_xsd_General, f, c),
_xsd_data_dir_ (_xsd_General._xsd_data_dir_,
                f | ::xml_schema::flags::not_root,
                this)
{
}

General::
General (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_data_dir_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void General::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // data_dir
    //
    {
      if (e.name () == "data-dir" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< data_dir::type > r (
          data_dir::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_data_dir_.present ())
          continue;
        this->data_dir (r);
        continue;
      }
    }
  }

  if (!_xsd_data_dir_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "data-dir",
      "");
  }
}

General* General::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new General (*this, f, c);
}

// BoardBorderConfiguration
//

BoardBorderConfiguration::
BoardBorderConfiguration (const visible::type& _xsd_visible,
                          const color::type& _xsd_color,
                          const font::type& _xsd_font,
                          const text_color::type& _xsd_text_color)
: ::xml_schema::type (),
_xsd_visible_ (_xsd_visible,
               ::xml_schema::flags (),
               this),
_xsd_color_ (_xsd_color,
             ::xml_schema::flags (),
             this),
_xsd_font_ (_xsd_font,
            ::xml_schema::flags (),
            this),
_xsd_text_color_ (_xsd_text_color,
                  ::xml_schema::flags (),
                  this)
{
}

BoardBorderConfiguration::
BoardBorderConfiguration (const BoardBorderConfiguration& _xsd_BoardBorderConfiguration,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
: ::xml_schema::type (_xsd_BoardBorderConfiguration, f, c),
_xsd_visible_ (_xsd_BoardBorderConfiguration._xsd_visible_,
               f | ::xml_schema::flags::not_root,
               this),
_xsd_color_ (_xsd_BoardBorderConfiguration._xsd_color_,
             f | ::xml_schema::flags::not_root,
             this),
_xsd_font_ (_xsd_BoardBorderConfiguration._xsd_font_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_text_color_ (_xsd_BoardBorderConfiguration._xsd_text_color_,
                  f | ::xml_schema::flags::not_root,
                  this)
{
}

BoardBorderConfiguration::
BoardBorderConfiguration (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_visible_ (f | ::xml_schema::flags::not_root, this),
_xsd_color_ (f | ::xml_schema::flags::not_root, this),
_xsd_font_ (f | ::xml_schema::flags::not_root, this),
_xsd_text_color_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void BoardBorderConfiguration::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // visible
    //
    {
      if (e.name () == "visible" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< visible::type > r (
          visible::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_visible_.present ())
          continue;
        this->visible (r);
        continue;
      }
    }

    // color
    //
    {
      if (e.name () == "color" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< color::type > r (
          color::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_color_.present ())
          continue;
        this->color (r);
        continue;
      }
    }

    // font
    //
    {
      if (e.name () == "font" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< font::type > r (
          font::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_font_.present ())
          continue;
        this->font (r);
        continue;
      }
    }

    // text_color
    //
    {
      if (e.name () == "text-color" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< text_color::type > r (
          text_color::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_text_color_.present ())
          continue;
        this->text_color (r);
        continue;
      }
    }
  }

  if (!_xsd_visible_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "visible",
      "");
  }

  if (!_xsd_color_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "color",
      "");
  }

  if (!_xsd_font_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "font",
      "");
  }

  if (!_xsd_text_color_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "text-color",
      "");
  }
}

BoardBorderConfiguration* BoardBorderConfiguration::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new BoardBorderConfiguration (*this, f, c);
}

// IcsConfiguration
//

IcsConfiguration::
IcsConfiguration (const username::type& _xsd_username,
                  const password::type& _xsd_password,
                  const host::type& _xsd_host,
                  const port::type& _xsd_port,
                  const timeseal::type& _xsd_timeseal)
: ::xml_schema::type (),
_xsd_username_ (_xsd_username,
                ::xml_schema::flags (),
                this),
_xsd_password_ (_xsd_password,
                ::xml_schema::flags (),
                this),
_xsd_host_ (_xsd_host,
            ::xml_schema::flags (),
            this),
_xsd_port_ (_xsd_port,
            ::xml_schema::flags (),
            this),
_xsd_timeseal_ (_xsd_timeseal,
                ::xml_schema::flags (),
                this)
{
}

IcsConfiguration::
IcsConfiguration (const IcsConfiguration& _xsd_IcsConfiguration,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
: ::xml_schema::type (_xsd_IcsConfiguration, f, c),
_xsd_username_ (_xsd_IcsConfiguration._xsd_username_,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_password_ (_xsd_IcsConfiguration._xsd_password_,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_host_ (_xsd_IcsConfiguration._xsd_host_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_port_ (_xsd_IcsConfiguration._xsd_port_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_timeseal_ (_xsd_IcsConfiguration._xsd_timeseal_,
                f | ::xml_schema::flags::not_root,
                this)
{
}

IcsConfiguration::
IcsConfiguration (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_username_ (f | ::xml_schema::flags::not_root, this),
_xsd_password_ (f | ::xml_schema::flags::not_root, this),
_xsd_host_ (f | ::xml_schema::flags::not_root, this),
_xsd_port_ (f | ::xml_schema::flags::not_root, this),
_xsd_timeseal_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void IcsConfiguration::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // username
    //
    {
      if (e.name () == "username" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< username::type > r (
          username::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_username_.present ())
          continue;
        this->username (r);
        continue;
      }
    }

    // password
    //
    {
      if (e.name () == "password" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< password::type > r (
          password::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_password_.present ())
          continue;
        this->password (r);
        continue;
      }
    }

    // host
    //
    {
      if (e.name () == "host" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< host::type > r (
          host::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_host_.present ())
          continue;
        this->host (r);
        continue;
      }
    }

    // port
    //
    {
      if (e.name () == "port" && e.namespace_ ().empty ())
      {
        if (_xsd_port_.present ())
          continue;
        this->port (
          port::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    // timeseal
    //
    {
      if (e.name () == "timeseal" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< timeseal::type > r (
          timeseal::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_timeseal_.present ())
          continue;
        this->timeseal (r);
        continue;
      }
    }
  }

  if (!_xsd_username_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "username",
      "");
  }

  if (!_xsd_password_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "password",
      "");
  }

  if (!_xsd_host_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "host",
      "");
  }

  if (!_xsd_port_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "port",
      "");
  }

  if (!_xsd_timeseal_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "timeseal",
      "");
  }
}

IcsConfiguration* IcsConfiguration::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new IcsConfiguration (*this, f, c);
}

// Timeseal
//

// Timeseal::use
// 

const Timeseal::use::type Timeseal::use::default_value_ (
  ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
    ::std::basic_string< char > ("false"), 0, 0, 0));

Timeseal::
Timeseal (const command::type& _xsd_command,
          const path::type& _xsd_path)
: ::xml_schema::type (),
_xsd_command_ (_xsd_command,
               ::xml_schema::flags (),
               this),
_xsd_path_ (_xsd_path,
            ::xml_schema::flags (),
            this),
_xsd_use_ (use::default_value (),
           ::xml_schema::flags (),
           this)
{
}

Timeseal::
Timeseal (const Timeseal& _xsd_Timeseal,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
: ::xml_schema::type (_xsd_Timeseal, f, c),
_xsd_command_ (_xsd_Timeseal._xsd_command_,
               f | ::xml_schema::flags::not_root,
               this),
_xsd_path_ (_xsd_Timeseal._xsd_path_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_use_ (_xsd_Timeseal._xsd_use_,
           f | ::xml_schema::flags::not_root,
           this)
{
}

Timeseal::
Timeseal (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_command_ (f | ::xml_schema::flags::not_root, this),
_xsd_path_ (f | ::xml_schema::flags::not_root, this),
_xsd_use_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void Timeseal::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // command
    //
    {
      if (e.name () == "command" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< command::type > r (
          command::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_command_.present ())
          continue;
        this->command (r);
        continue;
      }
    }

    // path
    //
    {
      if (e.name () == "path" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< path::type > r (
          path::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_path_.present ())
          continue;
        this->path (r);
        continue;
      }
    }
  }

  if (!_xsd_command_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "command",
      "");
  }

  if (!_xsd_path_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "path",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "use" && a.namespace_ ().empty ())
    {
      this->use (
        use::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }
  }

  if (!_xsd_use_.present ())
  {
    this->use (
      use::traits::create (
        ::std::basic_string< char > ("false"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

Timeseal* Timeseal::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new Timeseal (*this, f, c);
}

// TimesealCommand
//

// TimesealCommand::use
// 

const TimesealCommand::use::type TimesealCommand::use::default_value_ (
  ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
    ::std::basic_string< char > ("true"), 0, 0, 0));

TimesealCommand::
TimesealCommand (const _xsd_TimesealCommand::base_& _xsd_TimesealCommand)
: ::xml_schema::string (_xsd_TimesealCommand),
_xsd_use_ (use::default_value (),
           ::xml_schema::flags (),
           this)
{
}

TimesealCommand::
TimesealCommand (const TimesealCommand& _xsd_TimesealCommand,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
: ::xml_schema::string (_xsd_TimesealCommand, f, c),
_xsd_use_ (_xsd_TimesealCommand._xsd_use_,
           f | ::xml_schema::flags::not_root,
           this)
{
}

TimesealCommand::
TimesealCommand (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
: ::xml_schema::string (e, f, c),
_xsd_use_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void TimesealCommand::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "use" && a.namespace_ ().empty ())
    {
      this->use (
        use::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }
  }

  if (!_xsd_use_.present ())
  {
    this->use (
      use::traits::create (
        ::std::basic_string< char > ("true"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

TimesealCommand* TimesealCommand::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new TimesealCommand (*this, f, c);
}

// ClockConfiguration
//

ClockConfiguration::
ClockConfiguration (const background_color::type& _xsd_background_color,
                    const caption::type& _xsd_caption,
                    const decimals::type& _xsd_decimals,
                    const player::type& _xsd_player,
                    const time::type& _xsd_time)
: ::xml_schema::type (),
_xsd_background_color_ (_xsd_background_color,
                        ::xml_schema::flags (),
                        this),
_xsd_caption_ (_xsd_caption,
               ::xml_schema::flags (),
               this),
_xsd_decimals_ (_xsd_decimals,
                ::xml_schema::flags (),
                this),
_xsd_player_ (_xsd_player,
              ::xml_schema::flags (),
              this),
_xsd_time_ (_xsd_time,
            ::xml_schema::flags (),
            this)
{
}

ClockConfiguration::
ClockConfiguration (const ClockConfiguration& _xsd_ClockConfiguration,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xml_schema::type (_xsd_ClockConfiguration, f, c),
_xsd_background_color_ (_xsd_ClockConfiguration._xsd_background_color_,
                        f | ::xml_schema::flags::not_root,
                        this),
_xsd_caption_ (_xsd_ClockConfiguration._xsd_caption_,
               f | ::xml_schema::flags::not_root,
               this),
_xsd_decimals_ (_xsd_ClockConfiguration._xsd_decimals_,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_player_ (_xsd_ClockConfiguration._xsd_player_,
              f | ::xml_schema::flags::not_root,
              this),
_xsd_time_ (_xsd_ClockConfiguration._xsd_time_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

ClockConfiguration::
ClockConfiguration (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_background_color_ (f | ::xml_schema::flags::not_root, this),
_xsd_caption_ (f | ::xml_schema::flags::not_root, this),
_xsd_decimals_ (f | ::xml_schema::flags::not_root, this),
_xsd_player_ (f | ::xml_schema::flags::not_root, this),
_xsd_time_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void ClockConfiguration::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // background_color
    //
    {
      if (e.name () == "background-color" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< background_color::type > r (
          background_color::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_background_color_.present ())
          continue;
        this->background_color (r);
        continue;
      }
    }

    // caption
    //
    {
      if (e.name () == "caption" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< caption::type > r (
          caption::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_caption_.present ())
          continue;
        this->caption (r);
        continue;
      }
    }

    // decimals
    //
    {
      if (e.name () == "decimals" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< decimals::type > r (
          decimals::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_decimals_.present ())
          continue;
        this->decimals (r);
        continue;
      }
    }

    // player
    //
    {
      if (e.name () == "player" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< player::type > r (
          player::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_player_.present ())
          continue;
        this->player (r);
        continue;
      }
    }

    // time
    //
    {
      if (e.name () == "time" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< time::type > r (
          time::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_time_.present ())
          continue;
        this->time (r);
        continue;
      }
    }
  }

  if (!_xsd_background_color_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "background-color",
      "");
  }

  if (!_xsd_caption_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "caption",
      "");
  }

  if (!_xsd_decimals_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "decimals",
      "");
  }

  if (!_xsd_player_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "player",
      "");
  }

  if (!_xsd_time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "time",
      "");
  }
}

ClockConfiguration* ClockConfiguration::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new ClockConfiguration (*this, f, c);
}

// ClockElement
//

ClockElement::
ClockElement (const size::type& _xsd_size)
: ::xml_schema::type (),
_xsd_size_ (_xsd_size,
            ::xml_schema::flags (),
            this)
{
}

ClockElement::
ClockElement (const ClockElement& _xsd_ClockElement,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xml_schema::type (_xsd_ClockElement, f, c),
_xsd_size_ (_xsd_ClockElement._xsd_size_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

ClockElement::
ClockElement (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_size_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void ClockElement::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // size
    //
    {
      if (e.name () == "size" && e.namespace_ ().empty ())
      {
        if (_xsd_size_.present ())
          continue;
        this->size (
          size::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }
  }

  if (!_xsd_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "size",
      "");
  }
}

ClockElement* ClockElement::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new ClockElement (*this, f, c);
}

// HighlightingConfiguration
//

HighlightingConfiguration::
HighlightingConfiguration (const lua::type& _xsd_lua,
                           const simple_highlighting::type& _xsd_simple_highlighting)
: ::xml_schema::type (),
_xsd_lua_ (_xsd_lua,
           ::xml_schema::flags (),
           this),
_xsd_simple_highlighting_ (_xsd_simple_highlighting,
                           ::xml_schema::flags (),
                           this)
{
}

HighlightingConfiguration::
HighlightingConfiguration (const HighlightingConfiguration& _xsd_HighlightingConfiguration,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
: ::xml_schema::type (_xsd_HighlightingConfiguration, f, c),
_xsd_lua_ (_xsd_HighlightingConfiguration._xsd_lua_,
           f | ::xml_schema::flags::not_root,
           this),
_xsd_simple_highlighting_ (_xsd_HighlightingConfiguration._xsd_simple_highlighting_,
                           f | ::xml_schema::flags::not_root,
                           this)
{
}

HighlightingConfiguration::
HighlightingConfiguration (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_lua_ (f | ::xml_schema::flags::not_root, this),
_xsd_simple_highlighting_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void HighlightingConfiguration::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // lua
    //
    {
      if (e.name () == "lua" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< lua::type > r (
          lua::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_lua_.present ())
          continue;
        this->lua (r);
        continue;
      }
    }

    // simple_highlighting
    //
    {
      if (e.name () == "simple-highlighting" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< simple_highlighting::type > r (
          simple_highlighting::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_simple_highlighting_.present ())
          continue;
        this->simple_highlighting (r);
        continue;
      }
    }
  }

  if (!_xsd_lua_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "lua",
      "");
  }

  if (!_xsd_simple_highlighting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "simple-highlighting",
      "");
  }
}

HighlightingConfiguration* HighlightingConfiguration::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new HighlightingConfiguration (*this, f, c);
}

// LuaHLConfiguration
//

// LuaHLConfiguration::use
// 

const LuaHLConfiguration::use::type LuaHLConfiguration::use::default_value_ (
  ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
    ::std::basic_string< char > ("true"), 0, 0, 0));

LuaHLConfiguration::
LuaHLConfiguration (const library_path::type& _xsd_library_path,
                    const scripts::type& _xsd_scripts)
: ::xml_schema::type (),
_xsd_library_path_ (_xsd_library_path,
                    ::xml_schema::flags (),
                    this),
_xsd_scripts_ (_xsd_scripts,
               ::xml_schema::flags (),
               this),
_xsd_use_ (use::default_value (),
           ::xml_schema::flags (),
           this)
{
}

LuaHLConfiguration::
LuaHLConfiguration (const LuaHLConfiguration& _xsd_LuaHLConfiguration,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xml_schema::type (_xsd_LuaHLConfiguration, f, c),
_xsd_library_path_ (_xsd_LuaHLConfiguration._xsd_library_path_,
                    f | ::xml_schema::flags::not_root,
                    this),
_xsd_scripts_ (_xsd_LuaHLConfiguration._xsd_scripts_,
               f | ::xml_schema::flags::not_root,
               this),
_xsd_use_ (_xsd_LuaHLConfiguration._xsd_use_,
           f | ::xml_schema::flags::not_root,
           this)
{
}

LuaHLConfiguration::
LuaHLConfiguration (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_library_path_ (f | ::xml_schema::flags::not_root, this),
_xsd_scripts_ (f | ::xml_schema::flags::not_root, this),
_xsd_use_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void LuaHLConfiguration::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // library_path
    //
    {
      if (e.name () == "library-path" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< library_path::type > r (
          library_path::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_library_path_.present ())
          continue;
        this->library_path (r);
        continue;
      }
    }

    // scripts
    //
    {
      if (e.name () == "scripts" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< scripts::type > r (
          scripts::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_scripts_.present ())
          continue;
        this->scripts (r);
        continue;
      }
    }
  }

  if (!_xsd_library_path_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "library-path",
      "");
  }

  if (!_xsd_scripts_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "scripts",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "use" && a.namespace_ ().empty ())
    {
      this->use (
        use::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }
  }

  if (!_xsd_use_.present ())
  {
    this->use (
      use::traits::create (
        ::std::basic_string< char > ("true"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

LuaHLConfiguration* LuaHLConfiguration::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new LuaHLConfiguration (*this, f, c);
}

// ScriptList
//

ScriptList::
ScriptList ()
: ::xml_schema::type (),
_xsd_script_ (::xml_schema::flags (), this)
{
}

ScriptList::
ScriptList (const ScriptList& _xsd_ScriptList,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (_xsd_ScriptList, f, c),
_xsd_script_ (_xsd_ScriptList._xsd_script_,
              f | ::xml_schema::flags::not_root,
              this)
{
}

ScriptList::
ScriptList (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_script_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void ScriptList::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // script
    //
    {
      if (e.name () == "script" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< script::type > r (
          script::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        this->script ().push_back (r);
        continue;
      }
    }
  }
}

ScriptList* ScriptList::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new ScriptList (*this, f, c);
}

// SimpleHighlighting
//

SimpleHighlighting::
SimpleHighlighting ()
: ::xml_schema::type (),
_xsd_pattern_ (::xml_schema::flags (), this)
{
}

SimpleHighlighting::
SimpleHighlighting (const SimpleHighlighting& _xsd_SimpleHighlighting,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xml_schema::type (_xsd_SimpleHighlighting, f, c),
_xsd_pattern_ (_xsd_SimpleHighlighting._xsd_pattern_,
               f | ::xml_schema::flags::not_root,
               this)
{
}

SimpleHighlighting::
SimpleHighlighting (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_pattern_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void SimpleHighlighting::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // pattern
    //
    {
      if (e.name () == "pattern" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< pattern::type > r (
          pattern::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        this->pattern ().push_back (r);
        continue;
      }
    }
  }
}

SimpleHighlighting* SimpleHighlighting::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new SimpleHighlighting (*this, f, c);
}

// HighlightingPattern
//

HighlightingPattern::
HighlightingPattern (const name::type& _xsd_name,
                     const regexp::type& _xsd_regexp,
                     const format::type& _xsd_format)
: ::xml_schema::type (),
_xsd_name_ (_xsd_name,
            ::xml_schema::flags (),
            this),
_xsd_regexp_ (_xsd_regexp,
              ::xml_schema::flags (),
              this),
_xsd_format_ (_xsd_format,
              ::xml_schema::flags (),
              this)
{
}

HighlightingPattern::
HighlightingPattern (const HighlightingPattern& _xsd_HighlightingPattern,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xml_schema::type (_xsd_HighlightingPattern, f, c),
_xsd_name_ (_xsd_HighlightingPattern._xsd_name_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_regexp_ (_xsd_HighlightingPattern._xsd_regexp_,
              f | ::xml_schema::flags::not_root,
              this),
_xsd_format_ (_xsd_HighlightingPattern._xsd_format_,
              f | ::xml_schema::flags::not_root,
              this)
{
}

HighlightingPattern::
HighlightingPattern (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_name_ (f | ::xml_schema::flags::not_root, this),
_xsd_regexp_ (f | ::xml_schema::flags::not_root, this),
_xsd_format_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void HighlightingPattern::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // name
    //
    {
      if (e.name () == "name" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< name::type > r (
          name::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_name_.present ())
          continue;
        this->name (r);
        continue;
      }
    }

    // regexp
    //
    {
      if (e.name () == "regexp" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< regexp::type > r (
          regexp::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_regexp_.present ())
          continue;
        this->regexp (r);
        continue;
      }
    }

    // format
    //
    {
      if (e.name () == "format" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< format::type > r (
          format::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_format_.present ())
          continue;
        this->format (r);
        continue;
      }
    }
  }

  if (!_xsd_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!_xsd_regexp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "regexp",
      "");
  }

  if (!_xsd_format_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "format",
      "");
  }
}

HighlightingPattern* HighlightingPattern::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new HighlightingPattern (*this, f, c);
}

// HighlightingFormat
//

HighlightingFormat::
HighlightingFormat ()
: ::xml_schema::type (),
_xsd_bold_ (::xml_schema::flags (), this),
_xsd_italic_ (::xml_schema::flags (), this),
_xsd_color_ (::xml_schema::flags (), this)
{
}

HighlightingFormat::
HighlightingFormat (const HighlightingFormat& _xsd_HighlightingFormat,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xml_schema::type (_xsd_HighlightingFormat, f, c),
_xsd_bold_ (_xsd_HighlightingFormat._xsd_bold_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_italic_ (_xsd_HighlightingFormat._xsd_italic_,
              f | ::xml_schema::flags::not_root,
              this),
_xsd_color_ (_xsd_HighlightingFormat._xsd_color_,
             f | ::xml_schema::flags::not_root,
             this)
{
}

HighlightingFormat::
HighlightingFormat (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_bold_ (f | ::xml_schema::flags::not_root, this),
_xsd_italic_ (f | ::xml_schema::flags::not_root, this),
_xsd_color_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void HighlightingFormat::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // bold
    //
    {
      if (e.name () == "bold" && e.namespace_ ().empty ())
      {
        if (this->bold ())
          continue;
        this->bold (
          bold::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    // italic
    //
    {
      if (e.name () == "italic" && e.namespace_ ().empty ())
      {
        if (this->italic ())
          continue;
        this->italic (
          italic::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    // color
    //
    {
      if (e.name () == "color" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< color::type > r (
          color::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->color ())
          continue;
        this->color (r);
        continue;
      }
    }
  }
}

HighlightingFormat* HighlightingFormat::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new HighlightingFormat (*this, f, c);
}

// MovelistConfiguration
//

MovelistConfiguration::
MovelistConfiguration (const animations::type& _xsd_animations,
                       const comments::type& _xsd_comments,
                       const selection_color::type& _xsd_selection_color)
: ::xml_schema::type (),
_xsd_animations_ (_xsd_animations,
                  ::xml_schema::flags (),
                  this),
_xsd_comments_ (_xsd_comments,
                ::xml_schema::flags (),
                this),
_xsd_selection_color_ (_xsd_selection_color,
                       ::xml_schema::flags (),
                       this)
{
}

MovelistConfiguration::
MovelistConfiguration (const MovelistConfiguration& _xsd_MovelistConfiguration,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
: ::xml_schema::type (_xsd_MovelistConfiguration, f, c),
_xsd_animations_ (_xsd_MovelistConfiguration._xsd_animations_,
                  f | ::xml_schema::flags::not_root,
                  this),
_xsd_comments_ (_xsd_MovelistConfiguration._xsd_comments_,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_selection_color_ (_xsd_MovelistConfiguration._xsd_selection_color_,
                       f | ::xml_schema::flags::not_root,
                       this)
{
}

MovelistConfiguration::
MovelistConfiguration (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_animations_ (f | ::xml_schema::flags::not_root, this),
_xsd_comments_ (f | ::xml_schema::flags::not_root, this),
_xsd_selection_color_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void MovelistConfiguration::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // animations
    //
    {
      if (e.name () == "animations" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< animations::type > r (
          animations::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_animations_.present ())
          continue;
        this->animations (r);
        continue;
      }
    }

    // comments
    //
    {
      if (e.name () == "comments" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< comments::type > r (
          comments::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_comments_.present ())
          continue;
        this->comments (r);
        continue;
      }
    }

    // selection_color
    //
    {
      if (e.name () == "selection-color" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< selection_color::type > r (
          selection_color::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_selection_color_.present ())
          continue;
        this->selection_color (r);
        continue;
      }
    }
  }

  if (!_xsd_animations_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "animations",
      "");
  }

  if (!_xsd_comments_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "comments",
      "");
  }

  if (!_xsd_selection_color_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "selection-color",
      "");
  }
}

MovelistConfiguration* MovelistConfiguration::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new MovelistConfiguration (*this, f, c);
}

// MovelistAnimationConfiguration
//

MovelistAnimationConfiguration::
MovelistAnimationConfiguration (const speed::type& _xsd_speed,
                                const smoothness::type& _xsd_smoothness,
                                const animation_list::type& _xsd_animation_list)
: ::xml_schema::type (),
_xsd_speed_ (_xsd_speed,
             ::xml_schema::flags (),
             this),
_xsd_smoothness_ (_xsd_smoothness,
                  ::xml_schema::flags (),
                  this),
_xsd_animation_list_ (_xsd_animation_list,
                      ::xml_schema::flags (),
                      this),
_xsd_enabled_ (::xml_schema::flags (), this)
{
}

MovelistAnimationConfiguration::
MovelistAnimationConfiguration (const MovelistAnimationConfiguration& _xsd_MovelistAnimationConfiguration,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
: ::xml_schema::type (_xsd_MovelistAnimationConfiguration, f, c),
_xsd_speed_ (_xsd_MovelistAnimationConfiguration._xsd_speed_,
             f | ::xml_schema::flags::not_root,
             this),
_xsd_smoothness_ (_xsd_MovelistAnimationConfiguration._xsd_smoothness_,
                  f | ::xml_schema::flags::not_root,
                  this),
_xsd_animation_list_ (_xsd_MovelistAnimationConfiguration._xsd_animation_list_,
                      f | ::xml_schema::flags::not_root,
                      this),
_xsd_enabled_ (_xsd_MovelistAnimationConfiguration._xsd_enabled_,
               f | ::xml_schema::flags::not_root,
               this)
{
}

MovelistAnimationConfiguration::
MovelistAnimationConfiguration (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_speed_ (f | ::xml_schema::flags::not_root, this),
_xsd_smoothness_ (f | ::xml_schema::flags::not_root, this),
_xsd_animation_list_ (f | ::xml_schema::flags::not_root, this),
_xsd_enabled_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void MovelistAnimationConfiguration::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // speed
    //
    {
      if (e.name () == "speed" && e.namespace_ ().empty ())
      {
        if (_xsd_speed_.present ())
          continue;
        this->speed (
          speed::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    // smoothness
    //
    {
      if (e.name () == "smoothness" && e.namespace_ ().empty ())
      {
        if (_xsd_smoothness_.present ())
          continue;
        this->smoothness (
          smoothness::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    // animation_list
    //
    {
      if (e.name () == "animation-list" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< animation_list::type > r (
          animation_list::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_animation_list_.present ())
          continue;
        this->animation_list (r);
        continue;
      }
    }
  }

  if (!_xsd_speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "speed",
      "");
  }

  if (!_xsd_smoothness_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "smoothness",
      "");
  }

  if (!_xsd_animation_list_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "animation-list",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "enabled" && a.namespace_ ().empty ())
    {
      this->enabled (
        enabled::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }
  }
}

MovelistAnimationConfiguration* MovelistAnimationConfiguration::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new MovelistAnimationConfiguration (*this, f, c);
}

// MovelistAnimationList
//

MovelistAnimationList::
MovelistAnimationList (const hide_show::type& _xsd_hide_show,
                       const highlight::type& _xsd_highlight,
                       const moving::type& _xsd_moving)
: ::xml_schema::type (),
_xsd_hide_show_ (_xsd_hide_show,
                 ::xml_schema::flags (),
                 this),
_xsd_highlight_ (_xsd_highlight,
                 ::xml_schema::flags (),
                 this),
_xsd_moving_ (_xsd_moving,
              ::xml_schema::flags (),
              this)
{
}

MovelistAnimationList::
MovelistAnimationList (const MovelistAnimationList& _xsd_MovelistAnimationList,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
: ::xml_schema::type (_xsd_MovelistAnimationList, f, c),
_xsd_hide_show_ (_xsd_MovelistAnimationList._xsd_hide_show_,
                 f | ::xml_schema::flags::not_root,
                 this),
_xsd_highlight_ (_xsd_MovelistAnimationList._xsd_highlight_,
                 f | ::xml_schema::flags::not_root,
                 this),
_xsd_moving_ (_xsd_MovelistAnimationList._xsd_moving_,
              f | ::xml_schema::flags::not_root,
              this)
{
}

MovelistAnimationList::
MovelistAnimationList (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_hide_show_ (f | ::xml_schema::flags::not_root, this),
_xsd_highlight_ (f | ::xml_schema::flags::not_root, this),
_xsd_moving_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void MovelistAnimationList::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // hide_show
    //
    {
      if (e.name () == "hide-show" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< hide_show::type > r (
          hide_show::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_hide_show_.present ())
          continue;
        this->hide_show (r);
        continue;
      }
    }

    // highlight
    //
    {
      if (e.name () == "highlight" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< highlight::type > r (
          highlight::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_highlight_.present ())
          continue;
        this->highlight (r);
        continue;
      }
    }

    // moving
    //
    {
      if (e.name () == "moving" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< moving::type > r (
          moving::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_moving_.present ())
          continue;
        this->moving (r);
        continue;
      }
    }
  }

  if (!_xsd_hide_show_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "hide-show",
      "");
  }

  if (!_xsd_highlight_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "highlight",
      "");
  }

  if (!_xsd_moving_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "moving",
      "");
  }
}

MovelistAnimationList* MovelistAnimationList::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new MovelistAnimationList (*this, f, c);
}

// MovelistAnimation
//

// MovelistAnimation::enabled
// 

const MovelistAnimation::enabled::type MovelistAnimation::enabled::default_value_ (
  ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
    ::std::basic_string< char > ("false"), 0, 0, 0));

MovelistAnimation::
MovelistAnimation ()
: ::xml_schema::type (),
_xsd_enabled_ (enabled::default_value (),
               ::xml_schema::flags (),
               this)
{
}

MovelistAnimation::
MovelistAnimation (const MovelistAnimation& _xsd_MovelistAnimation,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::xml_schema::type (_xsd_MovelistAnimation, f, c),
_xsd_enabled_ (_xsd_MovelistAnimation._xsd_enabled_,
               f | ::xml_schema::flags::not_root,
               this)
{
}

MovelistAnimation::
MovelistAnimation (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_enabled_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void MovelistAnimation::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "enabled" && a.namespace_ ().empty ())
    {
      this->enabled (
        enabled::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }
  }

  if (!_xsd_enabled_.present ())
  {
    this->enabled (
      enabled::traits::create (
        ::std::basic_string< char > ("false"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

MovelistAnimation* MovelistAnimation::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new MovelistAnimation (*this, f, c);
}

// MovelistComments
//

MovelistComments::
MovelistComments (const color::type& _xsd_color,
                  const font::type& _xsd_font)
: ::xml_schema::type (),
_xsd_color_ (_xsd_color,
             ::xml_schema::flags (),
             this),
_xsd_font_ (_xsd_font,
            ::xml_schema::flags (),
            this)
{
}

MovelistComments::
MovelistComments (const MovelistComments& _xsd_MovelistComments,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
: ::xml_schema::type (_xsd_MovelistComments, f, c),
_xsd_color_ (_xsd_MovelistComments._xsd_color_,
             f | ::xml_schema::flags::not_root,
             this),
_xsd_font_ (_xsd_MovelistComments._xsd_font_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

MovelistComments::
MovelistComments (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_color_ (f | ::xml_schema::flags::not_root, this),
_xsd_font_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void MovelistComments::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // color
    //
    {
      if (e.name () == "color" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< color::type > r (
          color::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_color_.present ())
          continue;
        this->color (r);
        continue;
      }
    }

    // font
    //
    {
      if (e.name () == "font" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< font::type > r (
          font::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_font_.present ())
          continue;
        this->font (r);
        continue;
      }
    }
  }

  if (!_xsd_color_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "color",
      "");
  }

  if (!_xsd_font_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "font",
      "");
  }
}

MovelistComments* MovelistComments::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new MovelistComments (*this, f, c);
}

// VariantConfiguration
//

VariantConfiguration::
VariantConfiguration ()
: ::xml_schema::type (),
_xsd_variant_ (::xml_schema::flags (), this)
{
}

VariantConfiguration::
VariantConfiguration (const VariantConfiguration& _xsd_VariantConfiguration,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
: ::xml_schema::type (_xsd_VariantConfiguration, f, c),
_xsd_variant_ (_xsd_VariantConfiguration._xsd_variant_,
               f | ::xml_schema::flags::not_root,
               this)
{
}

VariantConfiguration::
VariantConfiguration (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_variant_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void VariantConfiguration::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // variant
    //
    {
      if (e.name () == "variant" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< variant::type > r (
          variant::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        this->variant ().push_back (r);
        continue;
      }
    }
  }
}

VariantConfiguration* VariantConfiguration::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new VariantConfiguration (*this, f, c);
}

// Variant
//

Variant::
Variant (const name::type& _xsd_name,
         const theme::type& _xsd_theme)
: ::xml_schema::type (),
_xsd_name_ (_xsd_name,
            ::xml_schema::flags (),
            this),
_xsd_theme_ (_xsd_theme,
             ::xml_schema::flags (),
             this)
{
}

Variant::
Variant (const Variant& _xsd_Variant,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
: ::xml_schema::type (_xsd_Variant, f, c),
_xsd_name_ (_xsd_Variant._xsd_name_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_theme_ (_xsd_Variant._xsd_theme_,
             f | ::xml_schema::flags::not_root,
             this)
{
}

Variant::
Variant (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_name_ (f | ::xml_schema::flags::not_root, this),
_xsd_theme_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void Variant::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // name
    //
    {
      if (e.name () == "name" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< name::type > r (
          name::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_name_.present ())
          continue;
        this->name (r);
        continue;
      }
    }

    // theme
    //
    {
      if (e.name () == "theme" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< theme::type > r (
          theme::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_theme_.present ())
          continue;
        this->theme (r);
        continue;
      }
    }
  }

  if (!_xsd_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!_xsd_theme_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "theme",
      "");
  }
}

Variant* Variant::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new Variant (*this, f, c);
}

// VariantTheme
//

// VariantTheme::inherit_pieces
// 

const VariantTheme::inherit_pieces::type VariantTheme::inherit_pieces::default_value_ (
  ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
    ::std::basic_string< char > ("false"), 0, 0, 0));

// VariantTheme::inherit_squares
// 

const VariantTheme::inherit_squares::type VariantTheme::inherit_squares::default_value_ (
  ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
    ::std::basic_string< char > ("false"), 0, 0, 0));

VariantTheme::
VariantTheme (const pieces::type& _xsd_pieces,
              const squares::type& _xsd_squares)
: ::xml_schema::type (),
_xsd_pieces_ (_xsd_pieces,
              ::xml_schema::flags (),
              this),
_xsd_squares_ (_xsd_squares,
               ::xml_schema::flags (),
               this),
_xsd_inherit_pieces_ (inherit_pieces::default_value (),
                      ::xml_schema::flags (),
                      this),
_xsd_inherit_squares_ (inherit_squares::default_value (),
                       ::xml_schema::flags (),
                       this)
{
}

VariantTheme::
VariantTheme (const VariantTheme& _xsd_VariantTheme,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xml_schema::type (_xsd_VariantTheme, f, c),
_xsd_pieces_ (_xsd_VariantTheme._xsd_pieces_,
              f | ::xml_schema::flags::not_root,
              this),
_xsd_squares_ (_xsd_VariantTheme._xsd_squares_,
               f | ::xml_schema::flags::not_root,
               this),
_xsd_inherit_pieces_ (_xsd_VariantTheme._xsd_inherit_pieces_,
                      f | ::xml_schema::flags::not_root,
                      this),
_xsd_inherit_squares_ (_xsd_VariantTheme._xsd_inherit_squares_,
                       f | ::xml_schema::flags::not_root,
                       this)
{
}

VariantTheme::
VariantTheme (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_pieces_ (f | ::xml_schema::flags::not_root, this),
_xsd_squares_ (f | ::xml_schema::flags::not_root, this),
_xsd_inherit_pieces_ (f | ::xml_schema::flags::not_root, this),
_xsd_inherit_squares_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void VariantTheme::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // pieces
    //
    {
      if (e.name () == "pieces" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< pieces::type > r (
          pieces::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_pieces_.present ())
          continue;
        this->pieces (r);
        continue;
      }
    }

    // squares
    //
    {
      if (e.name () == "squares" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< squares::type > r (
          squares::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_squares_.present ())
          continue;
        this->squares (r);
        continue;
      }
    }
  }

  if (!_xsd_pieces_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "pieces",
      "");
  }

  if (!_xsd_squares_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "squares",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "inherit-pieces" && a.namespace_ ().empty ())
    {
      this->inherit_pieces (
        inherit_pieces::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "inherit-squares" && a.namespace_ ().empty ())
    {
      this->inherit_squares (
        inherit_squares::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }
  }

  if (!_xsd_inherit_pieces_.present ())
  {
    this->inherit_pieces (
      inherit_pieces::traits::create (
        ::std::basic_string< char > ("false"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }

  if (!_xsd_inherit_squares_.present ())
  {
    this->inherit_squares (
      inherit_squares::traits::create (
        ::std::basic_string< char > ("false"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

VariantTheme* VariantTheme::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new VariantTheme (*this, f, c);
}

// AnimationConfiguration
//

AnimationConfiguration::
AnimationConfiguration (const animation_list::type& _xsd_animation_list)
: ::xml_schema::type (),
_xsd_smoothness_ (::xml_schema::flags (), this),
_xsd_speed_ (::xml_schema::flags (), this),
_xsd_animation_list_ (_xsd_animation_list,
                      ::xml_schema::flags (),
                      this)
{
}

AnimationConfiguration::
AnimationConfiguration (const AnimationConfiguration& _xsd_AnimationConfiguration,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
: ::xml_schema::type (_xsd_AnimationConfiguration, f, c),
_xsd_smoothness_ (_xsd_AnimationConfiguration._xsd_smoothness_,
                  f | ::xml_schema::flags::not_root,
                  this),
_xsd_speed_ (_xsd_AnimationConfiguration._xsd_speed_,
             f | ::xml_schema::flags::not_root,
             this),
_xsd_animation_list_ (_xsd_AnimationConfiguration._xsd_animation_list_,
                      f | ::xml_schema::flags::not_root,
                      this)
{
}

AnimationConfiguration::
AnimationConfiguration (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_smoothness_ (f | ::xml_schema::flags::not_root, this),
_xsd_speed_ (f | ::xml_schema::flags::not_root, this),
_xsd_animation_list_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void AnimationConfiguration::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // smoothness
    //
    {
      if (e.name () == "smoothness" && e.namespace_ ().empty ())
      {
        if (this->smoothness ())
          continue;
        this->smoothness (
          smoothness::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    // speed
    //
    {
      if (e.name () == "speed" && e.namespace_ ().empty ())
      {
        if (this->speed ())
          continue;
        this->speed (
          speed::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    // animation_list
    //
    {
      if (e.name () == "animation-list" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< animation_list::type > r (
          animation_list::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_animation_list_.present ())
          continue;
        this->animation_list (r);
        continue;
      }
    }
  }

  if (!_xsd_animation_list_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "animation-list",
      "");
  }
}

AnimationConfiguration* AnimationConfiguration::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new AnimationConfiguration (*this, f, c);
}

// AnimationList
//

AnimationList::
AnimationList (const capture::type& _xsd_capture,
               const fade::type& _xsd_fade,
               const movement::type& _xsd_movement,
               const transform::type& _xsd_transform,
               const sequence::type& _xsd_sequence)
: ::xml_schema::type (),
_xsd_capture_ (_xsd_capture,
               ::xml_schema::flags (),
               this),
_xsd_fade_ (_xsd_fade,
            ::xml_schema::flags (),
            this),
_xsd_movement_ (_xsd_movement,
                ::xml_schema::flags (),
                this),
_xsd_transform_ (_xsd_transform,
                 ::xml_schema::flags (),
                 this),
_xsd_sequence_ (_xsd_sequence,
                ::xml_schema::flags (),
                this)
{
}

AnimationList::
AnimationList (const AnimationList& _xsd_AnimationList,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::type (_xsd_AnimationList, f, c),
_xsd_capture_ (_xsd_AnimationList._xsd_capture_,
               f | ::xml_schema::flags::not_root,
               this),
_xsd_fade_ (_xsd_AnimationList._xsd_fade_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_movement_ (_xsd_AnimationList._xsd_movement_,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_transform_ (_xsd_AnimationList._xsd_transform_,
                 f | ::xml_schema::flags::not_root,
                 this),
_xsd_sequence_ (_xsd_AnimationList._xsd_sequence_,
                f | ::xml_schema::flags::not_root,
                this)
{
}

AnimationList::
AnimationList (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_capture_ (f | ::xml_schema::flags::not_root, this),
_xsd_fade_ (f | ::xml_schema::flags::not_root, this),
_xsd_movement_ (f | ::xml_schema::flags::not_root, this),
_xsd_transform_ (f | ::xml_schema::flags::not_root, this),
_xsd_sequence_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void AnimationList::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // capture
    //
    {
      if (e.name () == "capture" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< capture::type > r (
          capture::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_capture_.present ())
          continue;
        this->capture (r);
        continue;
      }
    }

    // fade
    //
    {
      if (e.name () == "fade" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< fade::type > r (
          fade::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_fade_.present ())
          continue;
        this->fade (r);
        continue;
      }
    }

    // movement
    //
    {
      if (e.name () == "movement" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< movement::type > r (
          movement::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_movement_.present ())
          continue;
        this->movement (r);
        continue;
      }
    }

    // transform
    //
    {
      if (e.name () == "transform" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< transform::type > r (
          transform::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_transform_.present ())
          continue;
        this->transform (r);
        continue;
      }
    }

    // sequence
    //
    {
      if (e.name () == "sequence" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< sequence::type > r (
          sequence::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_sequence_.present ())
          continue;
        this->sequence (r);
        continue;
      }
    }
  }

  if (!_xsd_capture_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "capture",
      "");
  }

  if (!_xsd_fade_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "fade",
      "");
  }

  if (!_xsd_movement_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "movement",
      "");
  }

  if (!_xsd_transform_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "transform",
      "");
  }

  if (!_xsd_sequence_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sequence",
      "");
  }
}

AnimationList* AnimationList::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new AnimationList (*this, f, c);
}

// Animation
//

Animation::
Animation ()
: ::xml_schema::type (),
_xsd_enabled_ (::xml_schema::flags (), this)
{
}

Animation::
Animation (const Animation& _xsd_Animation,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xml_schema::type (_xsd_Animation, f, c),
_xsd_enabled_ (_xsd_Animation._xsd_enabled_,
               f | ::xml_schema::flags::not_root,
               this)
{
}

Animation::
Animation (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_enabled_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void Animation::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "enabled" && a.namespace_ ().empty ())
    {
      this->enabled (
        enabled::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }
  }
}

Animation* Animation::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new Animation (*this, f, c);
}

// SequenceAnimation
//

SequenceAnimation::
SequenceAnimation (const max::type& _xsd_max)
: ::Animation (),
_xsd_max_ (_xsd_max,
           ::xml_schema::flags (),
           this)
{
}

SequenceAnimation::
SequenceAnimation (const SequenceAnimation& _xsd_SequenceAnimation,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::Animation (_xsd_SequenceAnimation, f, c),
_xsd_max_ (_xsd_SequenceAnimation._xsd_max_,
           f | ::xml_schema::flags::not_root,
           this)
{
}

SequenceAnimation::
SequenceAnimation (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::Animation (e, f, c),
_xsd_max_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void SequenceAnimation::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // max
    //
    {
      if (e.name () == "max" && e.namespace_ ().empty ())
      {
        if (_xsd_max_.present ())
          continue;
        this->max (
          max::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }
  }

  if (!_xsd_max_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "max",
      "");
  }
}

SequenceAnimation* SequenceAnimation::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new SequenceAnimation (*this, f, c);
}

// EngineConfiguration
//

EngineConfiguration::
EngineConfiguration (const engine_list::type& _xsd_engine_list)
: ::xml_schema::type (),
_xsd_default__ (::xml_schema::flags (), this),
_xsd_engine_list_ (_xsd_engine_list,
                   ::xml_schema::flags (),
                   this)
{
}

EngineConfiguration::
EngineConfiguration (const EngineConfiguration& _xsd_EngineConfiguration,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xml_schema::type (_xsd_EngineConfiguration, f, c),
_xsd_default__ (_xsd_EngineConfiguration._xsd_default__,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_engine_list_ (_xsd_EngineConfiguration._xsd_engine_list_,
                   f | ::xml_schema::flags::not_root,
                   this)
{
}

EngineConfiguration::
EngineConfiguration (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_default__ (f | ::xml_schema::flags::not_root, this),
_xsd_engine_list_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void EngineConfiguration::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // default_
    //
    {
      if (e.name () == "default" && e.namespace_ ().empty ())
      {
        if (this->default_ ())
          continue;
        this->default_ (
          default_::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    // engine_list
    //
    {
      if (e.name () == "engine-list" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< engine_list::type > r (
          engine_list::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_engine_list_.present ())
          continue;
        this->engine_list (r);
        continue;
      }
    }
  }

  if (!_xsd_engine_list_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "engine-list",
      "");
  }
}

EngineConfiguration* EngineConfiguration::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new EngineConfiguration (*this, f, c);
}

// EngineList
//

EngineList::
EngineList ()
: ::xml_schema::type (),
_xsd_engine_ (::xml_schema::flags (), this)
{
}

EngineList::
EngineList (const EngineList& _xsd_EngineList,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (_xsd_EngineList, f, c),
_xsd_engine_ (_xsd_EngineList._xsd_engine_,
              f | ::xml_schema::flags::not_root,
              this)
{
}

EngineList::
EngineList (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_engine_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void EngineList::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // engine
    //
    {
      if (e.name () == "engine" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< engine::type > r (
          engine::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        this->engine ().push_back (r);
        continue;
      }
    }
  }
}

EngineList* EngineList::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new EngineList (*this, f, c);
}

// Engine
//

Engine::
Engine (const name::type& _xsd_name,
        const path::type& _xsd_path)
: ::xml_schema::type (),
_xsd_name_ (_xsd_name,
            ::xml_schema::flags (),
            this),
_xsd_path_ (_xsd_path,
            ::xml_schema::flags (),
            this),
_xsd_type_ (::xml_schema::flags (), this)
{
}

Engine::
Engine (const Engine& _xsd_Engine,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
: ::xml_schema::type (_xsd_Engine, f, c),
_xsd_name_ (_xsd_Engine._xsd_name_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_path_ (_xsd_Engine._xsd_path_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_type_ (_xsd_Engine._xsd_type_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

Engine::
Engine (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_name_ (f | ::xml_schema::flags::not_root, this),
_xsd_path_ (f | ::xml_schema::flags::not_root, this),
_xsd_type_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void Engine::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // name
    //
    {
      if (e.name () == "name" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< name::type > r (
          name::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_name_.present ())
          continue;
        this->name (r);
        continue;
      }
    }

    // path
    //
    {
      if (e.name () == "path" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< path::type > r (
          path::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_path_.present ())
          continue;
        this->path (r);
        continue;
      }
    }
  }

  if (!_xsd_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!_xsd_path_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "path",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "type" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< type::type_ > r (
        type::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->type (r);
      continue;
    }
  }
}

Engine* Engine::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new Engine (*this, f, c);
}

// EngineType
//

EngineType::
EngineType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_EngineType_convert ();
}

EngineType::
EngineType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_EngineType_convert ();
}

EngineType::
EngineType (const ::std::basic_string< char >& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_EngineType_convert ();
}

EngineType* EngineType::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new EngineType (*this, f, c);
}

EngineType::_xsd_EngineType EngineType::
_xsd_EngineType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EngineType_literals_);
  const _xsd_EngineType* i (::std::lower_bound (
                              _xsd_EngineType_indexes_,
                              _xsd_EngineType_indexes_ + 3,
                              *this,
                              c));

  if (i == _xsd_EngineType_indexes_ + 3 || _xsd_EngineType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EngineType::
_xsd_EngineType_literals_[3] =
{
  "xboard",
  "UCI",
  "kboard"
};

const EngineType::_xsd_EngineType EngineType::
_xsd_EngineType_indexes_[3] =
{
  ::EngineType::UCI,
  ::EngineType::kboard,
  ::EngineType::xboard
};

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::Configuration >
configuration (const ::std::basic_string< char >& u,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::configuration (
    static_cast< const ::xercesc::DOMDocument& > (*d), f);
}

::std::auto_ptr< ::Configuration >
configuration (const ::std::basic_string< char >& u,
               ::xsd::cxx::xml::error_handler< char >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d)
  {
    throw ::xsd::cxx::tree::parsing< char > ();
  }

  return ::configuration (
    static_cast< const ::xercesc::DOMDocument& > (*d), f);
}

::std::auto_ptr< ::Configuration >
configuration (const ::std::basic_string< char >& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d)
  {
    throw ::xsd::cxx::tree::parsing< char > ();
  }

  return ::configuration (
    static_cast< const ::xercesc::DOMDocument& > (*d), f);
}

::std::auto_ptr< ::Configuration >
configuration (::std::istream& is,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::configuration (wrap, f, p);
}

::std::auto_ptr< ::Configuration >
configuration (::std::istream& is,
               ::xsd::cxx::xml::error_handler< char >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::configuration (wrap, h, f, p);
}

::std::auto_ptr< ::Configuration >
configuration (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::configuration (wrap, h, f, p);
}

::std::auto_ptr< ::Configuration >
configuration (::std::istream& is,
               const ::std::basic_string< char >& sid,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::configuration (wrap, f, p);
}

::std::auto_ptr< ::Configuration >
configuration (::std::istream& is,
               const ::std::basic_string< char >& sid,
               ::xsd::cxx::xml::error_handler< char >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::configuration (wrap, h, f, p);
}

::std::auto_ptr< ::Configuration >
configuration (::std::istream& is,
               const ::std::basic_string< char >& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::configuration (wrap, h, f, p);
}

::std::auto_ptr< ::Configuration >
configuration (const ::xercesc::DOMInputSource& i,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::configuration (
    static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
}

::std::auto_ptr< ::Configuration >
configuration (const ::xercesc::DOMInputSource& i,
               ::xsd::cxx::xml::error_handler< char >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d)
  {
    throw ::xsd::cxx::tree::parsing< char > ();
  }

  return ::configuration (
    static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
}

::std::auto_ptr< ::Configuration >
configuration (const ::xercesc::DOMInputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d)
  {
    throw ::xsd::cxx::tree::parsing< char > ();
  }

  return ::configuration (
    static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
}

::std::auto_ptr< ::Configuration >
configuration (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< char >&)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
    (f & ::xml_schema::flags::keep_dom) 
    ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
    : 0);

  const ::xsd::cxx::xml::dom::element< char > e (
    c.get ()
    ? *c->getDocumentElement ()
    : *d.getDocumentElement ());

  if (e.name () == "configuration" &&
      e.namespace_ () == "")
  {
    ::std::auto_ptr< ::Configuration > r (
      ::xsd::cxx::tree::traits< ::Configuration, char >::create (
        e.dom_element (), f, 0));
    if (f & ::xml_schema::flags::keep_dom) c.release ();
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    e.name (),
    e.namespace_ (),
    "configuration",
    "");
}

#include <ostream>
#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/serialization.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

void
operator<< (::xercesc::DOMElement& e,
            const Configuration& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "general",
      e);
    s.dom_element () << i.general ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "animations",
      e);
    s.dom_element () << i.animations ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "board-border",
      e);
    s.dom_element () << i.board_border ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "ics",
      e);
    s.dom_element () << i.ics ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "clock",
      e);
    s.dom_element () << i.clock ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "highlighting",
      e);
    s.dom_element () << i.highlighting ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "movelist",
      e);
    s.dom_element () << i.movelist ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "variants",
      e);
    s.dom_element () << i.variants ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "engines",
      e);
    s.dom_element () << i.engines ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const General& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "data-dir",
      e);
    s.dom_element () << i.data_dir ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const BoardBorderConfiguration& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "visible",
      e);
    s.dom_element () << i.visible ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "color",
      e);
    s.dom_element () << i.color ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "font",
      e);
    s.dom_element () << i.font ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "text-color",
      e);
    s.dom_element () << i.text_color ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const IcsConfiguration& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "username",
      e);
    s.dom_element () << i.username ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "password",
      e);
    s.dom_element () << i.password ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "host",
      e);
    s.dom_element () << i.host ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "port",
      e);
    s.dom_element () << i.port ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "timeseal",
      e);
    s.dom_element () << i.timeseal ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const Timeseal& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "command",
      e);
    s.dom_element () << i.command ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "path",
      e);
    s.dom_element () << i.path ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "use",
      e);

    a.dom_attribute () << i.use ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const TimesealCommand& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "use",
      e);

    a.dom_attribute () << i.use ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const ClockConfiguration& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "background-color",
      e);
    s.dom_element () << i.background_color ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "caption",
      e);
    s.dom_element () << i.caption ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "decimals",
      e);
    s.dom_element () << i.decimals ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "player",
      e);
    s.dom_element () << i.player ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "time",
      e);
    s.dom_element () << i.time ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const ClockElement& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "size",
      e);
    s.dom_element () << i.size ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const HighlightingConfiguration& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "lua",
      e);
    s.dom_element () << i.lua ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "simple-highlighting",
      e);
    s.dom_element () << i.simple_highlighting ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const LuaHLConfiguration& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "library-path",
      e);
    s.dom_element () << i.library_path ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "scripts",
      e);
    s.dom_element () << i.scripts ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "use",
      e);

    a.dom_attribute () << i.use ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const ScriptList& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    for (ScriptList::script::const_iterator
         b (i.script ().begin ()), n (i.script ().end ());
         b != n; ++b)
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "script",
        e);
      s.dom_element () << *b;
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const SimpleHighlighting& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    for (SimpleHighlighting::pattern::const_iterator
         b (i.pattern ().begin ()), n (i.pattern ().end ());
         b != n; ++b)
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "pattern",
        e);
      s.dom_element () << *b;
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const HighlightingPattern& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "name",
      e);
    s.dom_element () << i.name ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "regexp",
      e);
    s.dom_element () << i.regexp ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "format",
      e);
    s.dom_element () << i.format ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const HighlightingFormat& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    if (i.bold ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "bold",
        e);
      s.dom_element () << *i.bold ();
    }
  }

  {
    if (i.italic ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "italic",
        e);
      s.dom_element () << *i.italic ();
    }
  }

  {
    if (i.color ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "color",
        e);
      s.dom_element () << *i.color ();
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const MovelistConfiguration& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "animations",
      e);
    s.dom_element () << i.animations ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "comments",
      e);
    s.dom_element () << i.comments ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "selection-color",
      e);
    s.dom_element () << i.selection_color ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const MovelistAnimationConfiguration& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "speed",
      e);
    s.dom_element () << i.speed ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "smoothness",
      e);
    s.dom_element () << i.smoothness ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "animation-list",
      e);
    s.dom_element () << i.animation_list ();
  }

  if (i.enabled ())
  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "enabled",
      e);

    a.dom_attribute () << *i.enabled ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const MovelistAnimationList& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "hide-show",
      e);
    s.dom_element () << i.hide_show ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "highlight",
      e);
    s.dom_element () << i.highlight ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "moving",
      e);
    s.dom_element () << i.moving ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const MovelistAnimation& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "enabled",
      e);

    a.dom_attribute () << i.enabled ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const MovelistComments& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "color",
      e);
    s.dom_element () << i.color ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "font",
      e);
    s.dom_element () << i.font ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const VariantConfiguration& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    for (VariantConfiguration::variant::const_iterator
         b (i.variant ().begin ()), n (i.variant ().end ());
         b != n; ++b)
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "variant",
        e);
      s.dom_element () << *b;
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const Variant& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "name",
      e);
    s.dom_element () << i.name ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "theme",
      e);
    s.dom_element () << i.theme ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const VariantTheme& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "pieces",
      e);
    s.dom_element () << i.pieces ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "squares",
      e);
    s.dom_element () << i.squares ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "inherit-pieces",
      e);

    a.dom_attribute () << i.inherit_pieces ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "inherit-squares",
      e);

    a.dom_attribute () << i.inherit_squares ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const AnimationConfiguration& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    if (i.smoothness ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "smoothness",
        e);
      s.dom_element () << *i.smoothness ();
    }
  }

  {
    if (i.speed ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "speed",
        e);
      s.dom_element () << *i.speed ();
    }
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "animation-list",
      e);
    s.dom_element () << i.animation_list ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const AnimationList& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "capture",
      e);
    s.dom_element () << i.capture ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "fade",
      e);
    s.dom_element () << i.fade ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "movement",
      e);
    s.dom_element () << i.movement ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "transform",
      e);
    s.dom_element () << i.transform ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "sequence",
      e);
    s.dom_element () << i.sequence ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const Animation& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  if (i.enabled ())
  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "enabled",
      e);

    a.dom_attribute () << *i.enabled ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const SequenceAnimation& i)
{
  e << static_cast< const ::Animation& > (i);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "max",
      e);
    s.dom_element () << i.max ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const EngineConfiguration& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    if (i.default_ ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "default",
        e);
      s.dom_element () << *i.default_ ();
    }
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "engine-list",
      e);
    s.dom_element () << i.engine_list ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const EngineList& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    for (EngineList::engine::const_iterator
         b (i.engine ().begin ()), n (i.engine ().end ());
         b != n; ++b)
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "engine",
        e);
      s.dom_element () << *b;
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const Engine& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "name",
      e);
    s.dom_element () << i.name ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "path",
      e);
    s.dom_element () << i.path ();
  }

  if (i.type ())
  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "type",
      e);

    a.dom_attribute () << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            EngineType i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,
            EngineType i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xsd::cxx::tree::list_stream< char >& l,
            EngineType i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
configuration (::xercesc::DOMDocument& d,
               const ::Configuration& s,
               ::xml_schema::flags)
{
  ::xsd::cxx::xml::dom::element< char > e (*d.getDocumentElement ());

  if (e.name () == "configuration" &&
      e.namespace_ () == "")
  {
    e.dom_element () << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      e.name (),
      e.namespace_ (),
      "configuration",
      "");
  }
}

::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
configuration (const ::Configuration& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
               ::xml_schema::flags f)
{
  try
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "configuration",
        "",
        m,
        f));
    ::configuration (*d, s, f);
    return d;
  }
  catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
  {
    throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
  }
  catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
  {
    throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
  }
}

void
configuration (::xercesc::XMLFormatTarget& t,
               const ::Configuration& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
               const ::std::basic_string< char >& e,
               ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::configuration (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
configuration (::xercesc::XMLFormatTarget& t,
               const ::Configuration& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
               ::xsd::cxx::xml::error_handler< char >& h,
               const ::std::basic_string< char >& e,
               ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::configuration (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
configuration (::xercesc::XMLFormatTarget& t,
               const ::Configuration& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::basic_string< char >& e,
               ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::configuration (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
configuration (::std::ostream& o,
               const ::Configuration& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
               const ::std::basic_string< char >& e,
               ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::configuration (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
configuration (::std::ostream& o,
               const ::Configuration& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
               ::xsd::cxx::xml::error_handler< char >& h,
               const ::std::basic_string< char >& e,
               ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::configuration (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
configuration (::std::ostream& o,
               const ::Configuration& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::basic_string< char >& e,
               ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::configuration (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

