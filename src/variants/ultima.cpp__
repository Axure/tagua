#include "ultima.h"
#include "controllers/game.impl.h"
#include "controllers/examination.h"
#include "controllers/localexamination.h"
#include "controllers/editposition.impl.h"
#include "controllers/observedgame.h"
#include "controllers/editgame.impl.h"
#include "piecepoolwidget.h"
#include "variant.impl.h"
#include "graphicalinfo.impl.h"
#include "poolgraphicalinfo.impl.h"
#include "animator.impl.h"
#include "boardmanager.impl.h"
#include "moveserializer.impl.h"
#include <iostream>

using namespace std;

QString UltimaPiece::typeName() const {
  switch (m_type) {
  case King:
    return "king";
  case Withdrawer:
    return "withdrawer";
  case Coordinator:
    return "coordinator";
  case Chameleon:
    return "chameleon";
  case LongLeaper:
    return "longleaper";
  case Pawn:
    return "pawn";
  case Immobilizer:
    return "immobilizer";
  default:
    return "";
  }
}

QString UltimaPiece::typeSymbol(Type type) {
  switch (type) {
  case King:
    return "K";
  case Withdrawer:
    return "W";
  case Coordinator:
    return "C";
  case Chameleon:
    return "X";
  case LongLeaper:
    return "L";
  case Pawn:
    return "P";
  case Immobilizer:
    return "I";
  default:
    return "";
  }
}

bool UltimaPiece::canMove(UltimaMove& m, const UltimaPosition& position) const {
  if (m_type == Chameleon) {
    typedef map<Type, vector<Point> > Map;
    Map possible_targets;
    
    bool valid = canMoveAs(m, position, m.targets, UltimaPiece::Chameleon);
    
    for (int i = 0; i < 7; i++) {
      Type t = static_cast<Type>(i);
      if (t != Chameleon) {
        possible_targets[t] = vector<Point>();
        bool keep_this = true;
        if (!canMoveAs(m, position, possible_targets[t], t)) 
          keep_this = false;
        else {
          if (possible_targets[t].size() == 0) {
            if (position[m.to]) {
              keep_this = true;
              possible_targets[t].push_back(m.to);
            }
            else
              keep_this = false;
          }
          else {
            for (uint j = 0; j < possible_targets[t].size(); j++) {
              Q_ASSERT(position[possible_targets[t][j]]);
              if (position[possible_targets[t][j]]->type() != t) {
                keep_this = false;
                break;
              }
            }
          }
        }
        
        if (!keep_this) {
          std::cout << "removing possible targets of type " << typeSymbol(t) << std::endl;
          possible_targets.erase(t);
        }
      }
    }
    
    for (Map::iterator i = possible_targets.begin();
          i != possible_targets.end(); ++i) {
      std::cout << "remaining targets of type " << typeSymbol(i->first) << std::endl;
      valid = true;
      copy(i->second.begin(),
           i->second.end(),
           back_insert_iterator<vector<Point> >(m.targets));
    }
    
    return valid;
  }
  else 
    return canMoveAs(m, position, m.targets, m_type);
}

bool UltimaPiece::checkPawnCapture(const UltimaPosition& position, const Point& p, 
                                    const Point& direction, vector<Point>& targets) const {
  Point opp = p + direction;
  Point f = opp + direction;
  
  if (!position.valid(f)) return false;
  if (position[opp] && position[opp]->color() != color()
    && position[f] && position[f]->color() == color()) {
    targets.push_back(opp);
    return true;
  }
  else return false;
}

bool UltimaPiece::canMoveAs(const UltimaMove& m, const UltimaPosition& position, 
                            vector<Point>& targets, Type actualType) const {
  Point delta = m.to - m.from;
  if (actualType == King)
    // the king moves exactly like a chess king
    return abs(delta.x) <= 1 && abs(delta.y) <= 1 && !sameColor(position[m.to]);
  else {
    PathInfo path = position.path(m.from, m.to);
    if (path.valid() && !position[m.to]) {
      
      // a long leaper is the only one that can jump
      if (actualType == LongLeaper) {
        Point step = delta.normalizeInfinity();
        // a long leaper move is pseudolegal if
        // between from and to there are only
        // opponent pieces, and they are not
        // consecutive
        bool last = false;
        Point p = m.from;
        while ((p += step) != m.to) {
          if (position[p]) {
            if (last || position[p]->color() == color()) return false;
            targets.push_back(p);
            last = true;
          }
          else last = false;
        }
        return true;
      }
      else {
        if (!path.clear()) return false;
        
        switch (actualType) {
        case Pawn:
          // move like a rook
          if (!path.parallel()) return false;
          
          // called specialized capture checks for each direction
          checkPawnCapture(position, m.to, Point(1,0), targets);
          checkPawnCapture(position, m.to, Point(0,1), targets);
          checkPawnCapture(position, m.to, Point(-1,0), targets);
          checkPawnCapture(position, m.to, Point(0,-1), targets);
          break;
          
        case Coordinator:
          {
            // find king position
            Point kingPos = position.findKing(m_color);
            Q_ASSERT(kingPos != Point::invalid());
            
            // capture on the other vertices of the rectangle
            // determined by m.to and kingPos
            Point t1(m.to.x, kingPos.y);
            Point t2(kingPos.x, m.to.y);
            
            if (position[t1] && position[t1]->color() != m_color)
              targets.push_back(t1);
            if (position[t2] && position[t2]->color() != m_color)
              targets.push_back(t2);
          }
          break;
        case Immobilizer:
          // the immobilizer cannot capture
          break;
        case Withdrawer:
          {
            Point dir = delta.normalizeInfinity();
            Point opp = m.from - dir;
            if (position.valid(opp) && position[opp] && position[opp]->color() != color())
              targets.push_back(opp);
          }
          break;
        case Chameleon:
          break;
        default:
          return false;
        
        }
        
        return true;
      }
      
    }
    
    return false;
  }  
}

bool UltimaPiece::equals(const UltimaPiece* other) const {
  return other && m_color == other->m_color && m_type == other->m_type;
}


bool UltimaPiece::sameColor(const UltimaPiece* other) const {
  return other && m_color == other->m_color;
}

UltimaPosition::UltimaPosition()
: m_turn(WHITE)
, m_board(8, 8) { };

UltimaPosition::~UltimaPosition() { }

#define SET_PIECE(i, j, color, type) \
  m_board[Point(i,j)] = new Piece(color, UltimaPiece::type)
void UltimaPosition::setup() {
  for (int i = 0; i < 8; i++) {
    SET_PIECE(i, 1, BLACK, Pawn);
    SET_PIECE(i, 6, WHITE, Pawn);
  }
  
  SET_PIECE(0,0, BLACK, Coordinator);
  SET_PIECE(1,0, BLACK, LongLeaper);
  SET_PIECE(2,0, BLACK, Chameleon);
  SET_PIECE(3,0, BLACK, Withdrawer);
  SET_PIECE(4,0, BLACK, King);
  SET_PIECE(5,0, BLACK, Chameleon);
  SET_PIECE(6,0, BLACK, LongLeaper);
  SET_PIECE(7,0, BLACK, Immobilizer);

  SET_PIECE(0,7, WHITE, Immobilizer);
  SET_PIECE(1,7, WHITE, LongLeaper);
  SET_PIECE(2,7, WHITE, Chameleon);
  SET_PIECE(3,7, WHITE, King);
  SET_PIECE(4,7, WHITE, Withdrawer);
  SET_PIECE(5,7, WHITE, Chameleon);
  SET_PIECE(6,7, WHITE, LongLeaper);
  SET_PIECE(7,7, WHITE, Coordinator);
  
  m_turn = WHITE;
}
#undef SET_PIECE

bool UltimaPosition::operator==(const UltimaPosition& other) const {
  return m_turn == other.m_turn
      && m_board == other.m_board;
}

UltimaPiece* UltimaPosition::operator[](const Point& p) const {
  return m_board[p];
}

void UltimaPosition::setPiece(const Point& p, Piece* piece) {
  delete m_board[p];
  m_board[p] = piece;
}

Point UltimaPosition::findKing(Piece::Color color) const {
  return m_board.find(UltimaPiece(color, UltimaPiece::King));
}

void UltimaPosition::dump() const { }


bool UltimaPosition::valid(const Point& p) const {
  return m_board.valid(p);
}

bool UltimaPosition::testMove(Move& m) const {
  return pseudolegal(m);
}

bool UltimaPosition::pseudolegal(Move& m) const {
  if (!m.valid()) return false;
  Q_ASSERT(valid(m.from));
  Piece* piece = m_board[m.from];
  Q_ASSERT(piece);
  
  if (m.from == m.to) return false;
  
  // a piece cannot move if it is near an opponent immobilizer
  // or near a chameleon if it is an immobilizer
  bool immobilized = false;
  for (int i = -1; i <= 1; ++i)
  for (int j = -1; j <= 1; ++j) {
    Point p = m.from + Point(i,j);
    if (!valid(p)) continue;
    if (m_board[p]
       && m_board[p]->color() != piece->color()) {
      Piece::Type type = m_board[p]->type();
      if (type == Piece::Immobilizer ||
          (piece->type() == Piece::Immobilizer && type == Piece::Chameleon)) {
        immobilized = true;
        break;
      }
    }
  }
  if (immobilized) {
    // an immobilized piece can move
    // if an only if the move is a suicide
    return m.to == Point::invalid();
  }

  if (piece->canMove(m, *this)) {
    return true;
  }
  else return false;
}

void UltimaPosition::move(const Move& m) {
  Q_ASSERT(m.valid());
  
  // remove targets
  for (uint i = 0; i < m.targets.size(); i++)
    if (m.targets[i] != Point::invalid()) setPiece(m.targets[i], 0);
  
  if (m.to == Point::invalid()) {
    // suicide
//    setPiece(m.from, 0);
    std::cout << "suicide on " << m.from << std::endl;
  }
  else {
    // normal move
    delete m_board[m.to];
    m_board[m.to] = m_board[m.from];
    m_board[m.from] = 0;
  }
  
  switchTurn();
}

void UltimaPosition::switchTurn() {
  m_turn = ChessPiece::oppositeColor(m_turn);
}

template class EditGameController<UltimaPosition>;
