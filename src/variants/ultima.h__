#ifndef ULTIMA_H
#define ULTIMA_H

#include <QMatrix>
#include "common.h"
#include "position.h"
#include "spriteloader.h"
#include "serverreference.h"

class UltimaMove;
class UltimaPosition;

class UltimaPiece {
public:
  enum Type {
    InvalidType = -1,
    Pawn,
    LongLeaper,
    Chameleon,
    Coordinator,
    Withdrawer,
    King,
    Immobilizer
  };
  typedef PieceColor Color;
private:
  Color m_color;
  Type m_type;

  bool checkPawnCapture(const UltimaPosition& position, const Point& pos, const Point& direction, std::vector<Point>& targets) const;
public:
  UltimaPiece(const Color& color, const Type& type)
  : m_color(color), m_type(type) { }
  UltimaPiece& operator=(const UltimaPiece& other) {
    m_color = other.m_color;
    m_type = other.m_type;
    return *this;
  }
  bool operator==(const UltimaPiece& other) const {
    return equals(&other);
  }

  Color color() const { return m_color; }
  Type type() const { return m_type; }
  QString typeName() const;

  bool equals(const UltimaPiece* other) const;
  bool sameColor(const UltimaPiece* other) const;
  static QString typeSymbol(Type type);

  bool canMove(UltimaMove& m, const UltimaPosition& pos) const;
  bool canMoveAs(const UltimaMove& m, const UltimaPosition& pos,
                 std::vector<Point>& targets, Type actualType) const;
};

class UltimaMove {
public:
  Point from;
  Point to;
  std::vector<Point> targets;

  UltimaMove(const Point& from, const Point& to, PieceType /* ignored */ = INVALID_TYPE)
  : from(from)
  , to(to) { }

  static UltimaMove invalid() {
    return UltimaMove(Point::invalid(), Point::invalid());
  }

  bool valid() const {
    return from != Point::invalid();
  }

  ChessMove::Type type() const { return ChessMove::Normal; }
};

class UltimaPosition {
public:
  typedef UltimaPiece Piece;
  typedef UltimaMove Move;
  typedef ChessPosition::State State;

  UltimaPosition();
  virtual ~UltimaPosition();
  virtual UltimaPosition* clone() const { return new UltimaPosition(*this); }

private:
  Piece::Color m_turn;
  PointerGrid<Piece> m_board;

public:
  virtual void setup();
  Piece::Color turn() const { return m_turn; }
  Piece* operator[](const Point& p) const;
  void setPiece(const Point& p, Piece* piece);
  bool operator==(const UltimaPosition& other) const;

  Point findKing(Piece::Color color) const;
  PathInfo path(const Point& from, const Point& to) const {
    return m_board.path(from, to);
  }

  bool valid(const Point& p) const;
  Move getMove(const AlgebraicNotation&, bool&) const {
                        Q_ASSERT(!"unimplemented"); return *(Move*)0; }
  bool testMove(Move&) const;
  bool pseudolegal(Move&) const;
  void move(const Move& mv);
  void switchTurn();
  State state() const { return ChessPosition::BlackWins; }

  void dump() const;
};

template <>
class LoadPieces<UltimaPosition> : public LoadPiecesBase<UltimaPosition> {
  typedef LoadPiecesBase<UltimaPosition> Base;
  typedef UltimaPiece Piece;
public:
  LoadPieces(InnerSpriteLoader& data, InnerSpriteLoader::Pixmaps& cache, int size)
  : Base(data, cache, size) { }

  #define LOAD(color, type) \
    load(Piece(color, Piece::type))
  virtual void apply() {
    LOAD(WHITE, King);
    LOAD(WHITE, Withdrawer);
    LOAD(WHITE, Coordinator);
    LOAD(WHITE, Chameleon);
    LOAD(WHITE, LongLeaper);
    LOAD(WHITE, Pawn);
    LOAD(BLACK, King);
    LOAD(BLACK, Withdrawer);
    LOAD(BLACK, Coordinator);
    LOAD(BLACK, Chameleon);
    LOAD(BLACK, LongLeaper);
    LOAD(BLACK, Pawn);

    loadUpsideDownRook(WHITE);
    loadUpsideDownRook(BLACK);
  }
  #undef LOAD

  void loadUpsideDownRook(Piece::Color color) {
    Piece coo(color, Piece::Coordinator);
    Piece imm(color, Piece::Immobilizer);

    SpriteStore::Token rookToken = PieceToken<Piece>::get(&coo);
    SpriteStore::Token immToken = PieceToken<UltimaPiece>::get(&imm);
    QImage rookImage = m_data.store->get(rookToken);
    QImage res = rookImage.transformed(
      QMatrix(1, 0, 0, -1, 0, rookImage.height()));
    m_data.store->add(immToken, res);
    scale(immToken);
  }
};


template <>
class MoveSerializer<UltimaPosition> {
  typedef UltimaPosition::Move Move;
  Move m_move;
public:
  MoveSerializer(const Move& m, const UltimaPosition& /*ref*/)
  : m_move(m) { }

  virtual QString SAN() const { return ""; }
};


template <>
struct ComparePosition<UltimaPosition> {
  static bool apply(const UltimaPosition& /*chessPos*/, const UltimaPosition& /*pos*/) {
    return true;
  }
};

#endif // ULTIMA_H
