KBoard is written in C++ using QT and KDE libraries. Its source code is highly modular, and aims at providing a flexible API for later extensions and generalizations.

== Controllers ==

Different behaviours are handled with different subclasses of the abstract base class '''<code>Controller</code>'''.
A concrete <code>Controller</code> subclass is instanciated every time the chessboard needs to be reset due to a new game event, or a new examination, and the like.

A <code>Controller</code> subclass has the following responsibilities:
* setup the view with an appropriate <code>Rules</code> instance;
* create a graphical info for the chosen variant;
* override <code>handleStyle12</code> and <code>handleMoveList</code>, to define its behaviour in response to server events;
* override <code>back</code>, <code>forward</code> and similar events, to define its behaviour in response to user events.

== <code>ChessBoardWidget</code> ==

<code>ChessBoardWidget</code> is the main KBoard graphical component. It is a widget containing a canvas containing <code>PieceSprite</code>s.

Its status is represented by two instance variables:

* <code>position</code>, of type <code>const ChessPosition*</code>,
* <code>sprites</code>, of type <code>Grid&lt;PieceSprite*&gt;</code>.

The first is the ''logical'' position of the ChessBoard, while the seconds represents sprite locations inside the canvas. They get syncronized either directly (''warping''), or with ''animations'' (using an <code>Animator</code>).

A direct syncronization is obtained calling the <code>updatePosition</code> method:

  void updatePosition(const ChessPosition* pos)  
* stop animations
* change sprites to reflect <code>pos</code>. Don't update unchanged sprites.

  AnimationGroup* forward(const ChessMove& move, ChessPosition* dest)
* create an animation group
* fill animation group using an animator
* activate animation group ?

=== How a controller handles style12 events ===

==== If <code>style12.index == game->last() + 1</code> ====

* retrieve the move from <code>style12.san</code>
* get a real <code>ChessMove</code> instance using <code>ChessPosition::getMove</code>
** if unsuccessful, try <code>style12.lastMove</code>
* test move against current position
* compute <code>newPosition</code>
* get an animation group using <code>ChessBoardWidget::forward</code>
* compare <code>newPosition</code> with <code>style12.position</code>
** add captures and anti-captures to the animation group according to <code>style12.position</code>

==== If <code>style12.index == game->last()</code> ====

When the controller receives such an event, it should be able to add captures and anticaptures to the ''current animation group'', which unfortunately is not guaranteed to exist anymore.
What happens when a user makes a move? <code>ChessBoardWidget</code> computes an approximation for the resulting position and calls forward, activating the corresponding animation group and updating <code>position</code>. Several things can happen
# the animation ends before any style12 events: in this case, the view can be simply updated with <code>updatePosition</code> when needed
# while animating, a style12 event referring to the newly created position arrives: see [[updating while animating]].
# while animating, an invalid move event arrives: all animations shall be stopped, while current animation shall be aborted and moving pieces shall be animated back to their original squares with double speed.

To distinguish between these alternatives, <code>ChessBoardWidget</code> shall keep a reference to the [[ChessBoardWidget current animation|current animation]].