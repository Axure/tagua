// Copyright (C) 2005-2006 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// In addition, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CONFIG_HXX
#define CONFIG_HXX

#include <xsd/cxx/version.hxx>

#if (XSD_INT_VERSION != 2030000L)
#error XSD runtime version mismatch
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>
#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/namespace-infomap.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type<type> simple_type;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef integer non_positive_integer;
  typedef integer non_negative_integer;
  typedef integer positive_integer;
  typedef integer negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef long double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken> nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< type, char, ncname > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::day< char, simple_type > day;
  typedef ::xsd::cxx::tree::month< char, simple_type > month;
  typedef ::xsd::cxx::tree::month_day< char, simple_type > month_day;
  typedef ::xsd::cxx::tree::year< char, simple_type > year;
  typedef ::xsd::cxx::tree::year_month< char, simple_type > year_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::serialization< char > serialization;
  typedef ::xsd::cxx::tree::no_namespace_mapping< char > no_namespace_mapping;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::xsi_already_in_use< char > xsi_already_in_use;
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  // Parsing/serialization error.
  //
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::errors< char > errors;

  // Error handler interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // Namespace information. Used in serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info < char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap < char > namespace_infomap;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // DOM user data key for back pointers to tree nodes.
  //
#ifndef XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA

  const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;

#endif
}

// Forward declarations.
//
class Configuration;
class General;
class BoardBorderConfiguration;
class IcsConfiguration;
class Timeseal;
class TimesealCommand;
class ClockConfiguration;
class ClockElement;
class HighlightingConfiguration;
class LuaHLConfiguration;
class ScriptList;
class SimpleHighlighting;
class HighlightingPattern;
class HighlightingFormat;
class MovelistConfiguration;
class MovelistAnimationConfiguration;
class MovelistAnimationList;
class MovelistAnimation;
class MovelistComments;
class VariantConfiguration;
class Variant;
class VariantTheme;
class AnimationConfiguration;
class AnimationList;
class Animation;
class SequenceAnimation;
class EngineConfiguration;
class EngineList;
class Engine;
class EngineType;

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

class Configuration: public ::xml_schema::type
{
  public:

  struct _xsd_Configuration
  {
    typedef ::xml_schema::type base_;
  };

  // general
  // 
  public:
  struct general
  {
    typedef ::General type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const general::type&
  general () const;

  general::type&
  general ();

  void
  general (const general::type&);

  void
  general (::std::auto_ptr< general::type >);

  // animations
  // 
  public:
  struct animations
  {
    typedef ::AnimationConfiguration type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const animations::type&
  animations () const;

  animations::type&
  animations ();

  void
  animations (const animations::type&);

  void
  animations (::std::auto_ptr< animations::type >);

  // board-border
  // 
  public:
  struct board_border
  {
    typedef ::BoardBorderConfiguration type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const board_border::type&
  board_border () const;

  board_border::type&
  board_border ();

  void
  board_border (const board_border::type&);

  void
  board_border (::std::auto_ptr< board_border::type >);

  // ics
  // 
  public:
  struct ics
  {
    typedef ::IcsConfiguration type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const ics::type&
  ics () const;

  ics::type&
  ics ();

  void
  ics (const ics::type&);

  void
  ics (::std::auto_ptr< ics::type >);

  // clock
  // 
  public:
  struct clock
  {
    typedef ::ClockConfiguration type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const clock::type&
  clock () const;

  clock::type&
  clock ();

  void
  clock (const clock::type&);

  void
  clock (::std::auto_ptr< clock::type >);

  // highlighting
  // 
  public:
  struct highlighting
  {
    typedef ::HighlightingConfiguration type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const highlighting::type&
  highlighting () const;

  highlighting::type&
  highlighting ();

  void
  highlighting (const highlighting::type&);

  void
  highlighting (::std::auto_ptr< highlighting::type >);

  // movelist
  // 
  public:
  struct movelist
  {
    typedef ::MovelistConfiguration type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const movelist::type&
  movelist () const;

  movelist::type&
  movelist ();

  void
  movelist (const movelist::type&);

  void
  movelist (::std::auto_ptr< movelist::type >);

  // variants
  // 
  public:
  struct variants
  {
    typedef ::VariantConfiguration type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const variants::type&
  variants () const;

  variants::type&
  variants ();

  void
  variants (const variants::type&);

  void
  variants (::std::auto_ptr< variants::type >);

  // engines
  // 
  public:
  struct engines
  {
    typedef ::EngineConfiguration type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const engines::type&
  engines () const;

  engines::type&
  engines ();

  void
  engines (const engines::type&);

  void
  engines (::std::auto_ptr< engines::type >);

  // Constructors.
  //
  public:
  Configuration (const general::type&,
                 const animations::type&,
                 const board_border::type&,
                 const ics::type&,
                 const clock::type&,
                 const highlighting::type&,
                 const movelist::type&,
                 const variants::type&,
                 const engines::type&);

  Configuration (const ::xercesc::DOMElement&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

  Configuration (const Configuration&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

  virtual Configuration*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< general::type > _xsd_general_;
  ::xsd::cxx::tree::one< animations::type > _xsd_animations_;
  ::xsd::cxx::tree::one< board_border::type > _xsd_board_border_;
  ::xsd::cxx::tree::one< ics::type > _xsd_ics_;
  ::xsd::cxx::tree::one< clock::type > _xsd_clock_;
  ::xsd::cxx::tree::one< highlighting::type > _xsd_highlighting_;
  ::xsd::cxx::tree::one< movelist::type > _xsd_movelist_;
  ::xsd::cxx::tree::one< variants::type > _xsd_variants_;
  ::xsd::cxx::tree::one< engines::type > _xsd_engines_;
};

class General: public ::xml_schema::type
{
  public:

  struct _xsd_General
  {
    typedef ::xml_schema::type base_;
  };

  // data-dir
  // 
  public:
  struct data_dir
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const data_dir::type&
  data_dir () const;

  data_dir::type&
  data_dir ();

  void
  data_dir (const data_dir::type&);

  void
  data_dir (::std::auto_ptr< data_dir::type >);

  // Constructors.
  //
  public:
  General (const data_dir::type&);

  General (const ::xercesc::DOMElement&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

  General (const General&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

  virtual General*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< data_dir::type > _xsd_data_dir_;
};

class BoardBorderConfiguration: public ::xml_schema::type
{
  public:

  struct _xsd_BoardBorderConfiguration
  {
    typedef ::xml_schema::type base_;
  };

  // visible
  // 
  public:
  struct visible
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const visible::type&
  visible () const;

  visible::type&
  visible ();

  void
  visible (const visible::type&);

  void
  visible (::std::auto_ptr< visible::type >);

  // color
  // 
  public:
  struct color
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const color::type&
  color () const;

  color::type&
  color ();

  void
  color (const color::type&);

  void
  color (::std::auto_ptr< color::type >);

  // font
  // 
  public:
  struct font
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const font::type&
  font () const;

  font::type&
  font ();

  void
  font (const font::type&);

  void
  font (::std::auto_ptr< font::type >);

  // text-color
  // 
  public:
  struct text_color
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const text_color::type&
  text_color () const;

  text_color::type&
  text_color ();

  void
  text_color (const text_color::type&);

  void
  text_color (::std::auto_ptr< text_color::type >);

  // Constructors.
  //
  public:
  BoardBorderConfiguration (const visible::type&,
                            const color::type&,
                            const font::type&,
                            const text_color::type&);

  BoardBorderConfiguration (const ::xercesc::DOMElement&,
                            ::xml_schema::flags = 0,
                            ::xml_schema::type* = 0);

  BoardBorderConfiguration (const BoardBorderConfiguration&,
                            ::xml_schema::flags = 0,
                            ::xml_schema::type* = 0);

  virtual BoardBorderConfiguration*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< visible::type > _xsd_visible_;
  ::xsd::cxx::tree::one< color::type > _xsd_color_;
  ::xsd::cxx::tree::one< font::type > _xsd_font_;
  ::xsd::cxx::tree::one< text_color::type > _xsd_text_color_;
};

class IcsConfiguration: public ::xml_schema::type
{
  public:

  struct _xsd_IcsConfiguration
  {
    typedef ::xml_schema::type base_;
  };

  // username
  // 
  public:
  struct username
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const username::type&
  username () const;

  username::type&
  username ();

  void
  username (const username::type&);

  void
  username (::std::auto_ptr< username::type >);

  // password
  // 
  public:
  struct password
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const password::type&
  password () const;

  password::type&
  password ();

  void
  password (const password::type&);

  void
  password (::std::auto_ptr< password::type >);

  // host
  // 
  public:
  struct host
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const host::type&
  host () const;

  host::type&
  host ();

  void
  host (const host::type&);

  void
  host (::std::auto_ptr< host::type >);

  // port
  // 
  public:
  struct port
  {
    typedef ::xml_schema::integer type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const port::type&
  port () const;

  port::type&
  port ();

  void
  port (const port::type&);

  // timeseal
  // 
  public:
  struct timeseal
  {
    typedef ::Timeseal type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const timeseal::type&
  timeseal () const;

  timeseal::type&
  timeseal ();

  void
  timeseal (const timeseal::type&);

  void
  timeseal (::std::auto_ptr< timeseal::type >);

  // Constructors.
  //
  public:
  IcsConfiguration (const username::type&,
                    const password::type&,
                    const host::type&,
                    const port::type&,
                    const timeseal::type&);

  IcsConfiguration (const ::xercesc::DOMElement&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

  IcsConfiguration (const IcsConfiguration&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

  virtual IcsConfiguration*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< username::type > _xsd_username_;
  ::xsd::cxx::tree::one< password::type > _xsd_password_;
  ::xsd::cxx::tree::one< host::type > _xsd_host_;
  ::xsd::cxx::tree::one< port::type > _xsd_port_;
  ::xsd::cxx::tree::one< timeseal::type > _xsd_timeseal_;
};

class Timeseal: public ::xml_schema::type
{
  public:

  struct _xsd_Timeseal
  {
    typedef ::xml_schema::type base_;
  };

  // command
  // 
  public:
  struct command
  {
    typedef ::TimesealCommand type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const command::type&
  command () const;

  command::type&
  command ();

  void
  command (const command::type&);

  void
  command (::std::auto_ptr< command::type >);

  // path
  // 
  public:
  struct path
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const path::type&
  path () const;

  path::type&
  path ();

  void
  path (const path::type&);

  void
  path (::std::auto_ptr< path::type >);

  // use
  // 
  public:
  struct use
  {
    typedef ::xml_schema::boolean type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;

    static const type&
    default_value ();

    private:
    static const type default_value_;
  };

  const use::type&
  use () const;

  use::type&
  use ();

  void
  use (const use::type&);

  // Constructors.
  //
  public:
  Timeseal (const command::type&,
            const path::type&);

  Timeseal (const ::xercesc::DOMElement&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

  Timeseal (const Timeseal&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

  virtual Timeseal*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< command::type > _xsd_command_;
  ::xsd::cxx::tree::one< path::type > _xsd_path_;
  ::xsd::cxx::tree::one< use::type > _xsd_use_;
};

class TimesealCommand: public ::xml_schema::string
{
  public:

  struct _xsd_TimesealCommand
  {
    typedef ::xml_schema::string base_;
  };

  // use
  // 
  public:
  struct use
  {
    typedef ::xml_schema::boolean type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;

    static const type&
    default_value ();

    private:
    static const type default_value_;
  };

  const use::type&
  use () const;

  use::type&
  use ();

  void
  use (const use::type&);

  // Constructors.
  //
  public:
  TimesealCommand (const _xsd_TimesealCommand::base_& );

  TimesealCommand (const ::xercesc::DOMElement&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

  TimesealCommand (const TimesealCommand&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

  virtual TimesealCommand*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< use::type > _xsd_use_;
};

class ClockConfiguration: public ::xml_schema::type
{
  public:

  struct _xsd_ClockConfiguration
  {
    typedef ::xml_schema::type base_;
  };

  // background-color
  // 
  public:
  struct background_color
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const background_color::type&
  background_color () const;

  background_color::type&
  background_color ();

  void
  background_color (const background_color::type&);

  void
  background_color (::std::auto_ptr< background_color::type >);

  // caption
  // 
  public:
  struct caption
  {
    typedef ::ClockElement type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const caption::type&
  caption () const;

  caption::type&
  caption ();

  void
  caption (const caption::type&);

  void
  caption (::std::auto_ptr< caption::type >);

  // decimals
  // 
  public:
  struct decimals
  {
    typedef ::ClockElement type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const decimals::type&
  decimals () const;

  decimals::type&
  decimals ();

  void
  decimals (const decimals::type&);

  void
  decimals (::std::auto_ptr< decimals::type >);

  // player
  // 
  public:
  struct player
  {
    typedef ::ClockElement type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const player::type&
  player () const;

  player::type&
  player ();

  void
  player (const player::type&);

  void
  player (::std::auto_ptr< player::type >);

  // time
  // 
  public:
  struct time
  {
    typedef ::ClockElement type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const time::type&
  time () const;

  time::type&
  time ();

  void
  time (const time::type&);

  void
  time (::std::auto_ptr< time::type >);

  // Constructors.
  //
  public:
  ClockConfiguration (const background_color::type&,
                      const caption::type&,
                      const decimals::type&,
                      const player::type&,
                      const time::type&);

  ClockConfiguration (const ::xercesc::DOMElement&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

  ClockConfiguration (const ClockConfiguration&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

  virtual ClockConfiguration*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< background_color::type > _xsd_background_color_;
  ::xsd::cxx::tree::one< caption::type > _xsd_caption_;
  ::xsd::cxx::tree::one< decimals::type > _xsd_decimals_;
  ::xsd::cxx::tree::one< player::type > _xsd_player_;
  ::xsd::cxx::tree::one< time::type > _xsd_time_;
};

class ClockElement: public ::xml_schema::type
{
  public:

  struct _xsd_ClockElement
  {
    typedef ::xml_schema::type base_;
  };

  // size
  // 
  public:
  struct size
  {
    typedef ::xml_schema::integer type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const size::type&
  size () const;

  size::type&
  size ();

  void
  size (const size::type&);

  // Constructors.
  //
  public:
  ClockElement (const size::type&);

  ClockElement (const ::xercesc::DOMElement&,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

  ClockElement (const ClockElement&,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

  virtual ClockElement*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< size::type > _xsd_size_;
};

class HighlightingConfiguration: public ::xml_schema::type
{
  public:

  struct _xsd_HighlightingConfiguration
  {
    typedef ::xml_schema::type base_;
  };

  // lua
  // 
  public:
  struct lua
  {
    typedef ::LuaHLConfiguration type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const lua::type&
  lua () const;

  lua::type&
  lua ();

  void
  lua (const lua::type&);

  void
  lua (::std::auto_ptr< lua::type >);

  // simple-highlighting
  // 
  public:
  struct simple_highlighting
  {
    typedef ::SimpleHighlighting type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const simple_highlighting::type&
  simple_highlighting () const;

  simple_highlighting::type&
  simple_highlighting ();

  void
  simple_highlighting (const simple_highlighting::type&);

  void
  simple_highlighting (::std::auto_ptr< simple_highlighting::type >);

  // Constructors.
  //
  public:
  HighlightingConfiguration (const lua::type&,
                             const simple_highlighting::type&);

  HighlightingConfiguration (const ::xercesc::DOMElement&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

  HighlightingConfiguration (const HighlightingConfiguration&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

  virtual HighlightingConfiguration*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< lua::type > _xsd_lua_;
  ::xsd::cxx::tree::one< simple_highlighting::type > _xsd_simple_highlighting_;
};

class LuaHLConfiguration: public ::xml_schema::type
{
  public:

  struct _xsd_LuaHLConfiguration
  {
    typedef ::xml_schema::type base_;
  };

  // library-path
  // 
  public:
  struct library_path
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const library_path::type&
  library_path () const;

  library_path::type&
  library_path ();

  void
  library_path (const library_path::type&);

  void
  library_path (::std::auto_ptr< library_path::type >);

  // scripts
  // 
  public:
  struct scripts
  {
    typedef ::ScriptList type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const scripts::type&
  scripts () const;

  scripts::type&
  scripts ();

  void
  scripts (const scripts::type&);

  void
  scripts (::std::auto_ptr< scripts::type >);

  // use
  // 
  public:
  struct use
  {
    typedef ::xml_schema::boolean type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;

    static const type&
    default_value ();

    private:
    static const type default_value_;
  };

  const use::type&
  use () const;

  use::type&
  use ();

  void
  use (const use::type&);

  // Constructors.
  //
  public:
  LuaHLConfiguration (const library_path::type&,
                      const scripts::type&);

  LuaHLConfiguration (const ::xercesc::DOMElement&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

  LuaHLConfiguration (const LuaHLConfiguration&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

  virtual LuaHLConfiguration*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< library_path::type > _xsd_library_path_;
  ::xsd::cxx::tree::one< scripts::type > _xsd_scripts_;
  ::xsd::cxx::tree::one< use::type > _xsd_use_;
};

class ScriptList: public ::xml_schema::type
{
  public:

  struct _xsd_ScriptList
  {
    typedef ::xml_schema::type base_;
  };

  // script
  // 
  public:
  struct script
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::sequence< type > container;
    typedef container::iterator iterator;
    typedef container::const_iterator const_iterator;
  };

  const script::container&
  script () const;

  script::container&
  script ();

  void
  script (const script::container&);

  // Constructors.
  //
  public:
  ScriptList ();

  ScriptList (const ::xercesc::DOMElement&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

  ScriptList (const ScriptList&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

  virtual ScriptList*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::sequence< script::type > _xsd_script_;
};

class SimpleHighlighting: public ::xml_schema::type
{
  public:

  struct _xsd_SimpleHighlighting
  {
    typedef ::xml_schema::type base_;
  };

  // pattern
  // 
  public:
  struct pattern
  {
    typedef ::HighlightingPattern type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::sequence< type > container;
    typedef container::iterator iterator;
    typedef container::const_iterator const_iterator;
  };

  const pattern::container&
  pattern () const;

  pattern::container&
  pattern ();

  void
  pattern (const pattern::container&);

  // Constructors.
  //
  public:
  SimpleHighlighting ();

  SimpleHighlighting (const ::xercesc::DOMElement&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

  SimpleHighlighting (const SimpleHighlighting&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

  virtual SimpleHighlighting*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::sequence< pattern::type > _xsd_pattern_;
};

class HighlightingPattern: public ::xml_schema::type
{
  public:

  struct _xsd_HighlightingPattern
  {
    typedef ::xml_schema::type base_;
  };

  // name
  // 
  public:
  struct name
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const name::type&
  name () const;

  name::type&
  name ();

  void
  name (const name::type&);

  void
  name (::std::auto_ptr< name::type >);

  // regexp
  // 
  public:
  struct regexp
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const regexp::type&
  regexp () const;

  regexp::type&
  regexp ();

  void
  regexp (const regexp::type&);

  void
  regexp (::std::auto_ptr< regexp::type >);

  // format
  // 
  public:
  struct format
  {
    typedef ::HighlightingFormat type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const format::type&
  format () const;

  format::type&
  format ();

  void
  format (const format::type&);

  void
  format (::std::auto_ptr< format::type >);

  // Constructors.
  //
  public:
  HighlightingPattern (const name::type&,
                       const regexp::type&,
                       const format::type&);

  HighlightingPattern (const ::xercesc::DOMElement&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

  HighlightingPattern (const HighlightingPattern&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

  virtual HighlightingPattern*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< name::type > _xsd_name_;
  ::xsd::cxx::tree::one< regexp::type > _xsd_regexp_;
  ::xsd::cxx::tree::one< format::type > _xsd_format_;
};

class HighlightingFormat: public ::xml_schema::type
{
  public:

  struct _xsd_HighlightingFormat
  {
    typedef ::xml_schema::type base_;
  };

  // bold
  // 
  public:
  struct bold
  {
    typedef ::xml_schema::boolean type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::optional< type > container;
  };

  const bold::container&
  bold () const;

  bold::container&
  bold ();

  void
  bold (const bold::type&);

  void
  bold (const bold::container&);

  // italic
  // 
  public:
  struct italic
  {
    typedef ::xml_schema::boolean type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::optional< type > container;
  };

  const italic::container&
  italic () const;

  italic::container&
  italic ();

  void
  italic (const italic::type&);

  void
  italic (const italic::container&);

  // color
  // 
  public:
  struct color
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::optional< type > container;
  };

  const color::container&
  color () const;

  color::container&
  color ();

  void
  color (const color::type&);

  void
  color (const color::container&);

  void
  color (::std::auto_ptr< color::type >);

  // Constructors.
  //
  public:
  HighlightingFormat ();

  HighlightingFormat (const ::xercesc::DOMElement&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

  HighlightingFormat (const HighlightingFormat&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

  virtual HighlightingFormat*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::optional< bold::type > _xsd_bold_;
  ::xsd::cxx::tree::optional< italic::type > _xsd_italic_;
  ::xsd::cxx::tree::optional< color::type > _xsd_color_;
};

class MovelistConfiguration: public ::xml_schema::type
{
  public:

  struct _xsd_MovelistConfiguration
  {
    typedef ::xml_schema::type base_;
  };

  // animations
  // 
  public:
  struct animations
  {
    typedef ::MovelistAnimationConfiguration type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const animations::type&
  animations () const;

  animations::type&
  animations ();

  void
  animations (const animations::type&);

  void
  animations (::std::auto_ptr< animations::type >);

  // comments
  // 
  public:
  struct comments
  {
    typedef ::MovelistComments type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const comments::type&
  comments () const;

  comments::type&
  comments ();

  void
  comments (const comments::type&);

  void
  comments (::std::auto_ptr< comments::type >);

  // selection-color
  // 
  public:
  struct selection_color
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const selection_color::type&
  selection_color () const;

  selection_color::type&
  selection_color ();

  void
  selection_color (const selection_color::type&);

  void
  selection_color (::std::auto_ptr< selection_color::type >);

  // Constructors.
  //
  public:
  MovelistConfiguration (const animations::type&,
                         const comments::type&,
                         const selection_color::type&);

  MovelistConfiguration (const ::xercesc::DOMElement&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

  MovelistConfiguration (const MovelistConfiguration&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

  virtual MovelistConfiguration*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< animations::type > _xsd_animations_;
  ::xsd::cxx::tree::one< comments::type > _xsd_comments_;
  ::xsd::cxx::tree::one< selection_color::type > _xsd_selection_color_;
};

class MovelistAnimationConfiguration: public ::xml_schema::type
{
  public:

  struct _xsd_MovelistAnimationConfiguration
  {
    typedef ::xml_schema::type base_;
  };

  // speed
  // 
  public:
  struct speed
  {
    typedef ::xml_schema::integer type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const speed::type&
  speed () const;

  speed::type&
  speed ();

  void
  speed (const speed::type&);

  // smoothness
  // 
  public:
  struct smoothness
  {
    typedef ::xml_schema::integer type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const smoothness::type&
  smoothness () const;

  smoothness::type&
  smoothness ();

  void
  smoothness (const smoothness::type&);

  // animation-list
  // 
  public:
  struct animation_list
  {
    typedef ::MovelistAnimationList type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const animation_list::type&
  animation_list () const;

  animation_list::type&
  animation_list ();

  void
  animation_list (const animation_list::type&);

  void
  animation_list (::std::auto_ptr< animation_list::type >);

  // enabled
  // 
  public:
  struct enabled
  {
    typedef ::xml_schema::boolean type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::optional< type > container;
  };

  const enabled::container&
  enabled () const;

  enabled::container&
  enabled ();

  void
  enabled (const enabled::type&);

  void
  enabled (const enabled::container&);

  // Constructors.
  //
  public:
  MovelistAnimationConfiguration (const speed::type&,
                                  const smoothness::type&,
                                  const animation_list::type&);

  MovelistAnimationConfiguration (const ::xercesc::DOMElement&,
                                  ::xml_schema::flags = 0,
                                  ::xml_schema::type* = 0);

  MovelistAnimationConfiguration (const MovelistAnimationConfiguration&,
                                  ::xml_schema::flags = 0,
                                  ::xml_schema::type* = 0);

  virtual MovelistAnimationConfiguration*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< speed::type > _xsd_speed_;
  ::xsd::cxx::tree::one< smoothness::type > _xsd_smoothness_;
  ::xsd::cxx::tree::one< animation_list::type > _xsd_animation_list_;
  ::xsd::cxx::tree::optional< enabled::type > _xsd_enabled_;
};

class MovelistAnimationList: public ::xml_schema::type
{
  public:

  struct _xsd_MovelistAnimationList
  {
    typedef ::xml_schema::type base_;
  };

  // hide-show
  // 
  public:
  struct hide_show
  {
    typedef ::MovelistAnimation type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const hide_show::type&
  hide_show () const;

  hide_show::type&
  hide_show ();

  void
  hide_show (const hide_show::type&);

  void
  hide_show (::std::auto_ptr< hide_show::type >);

  // highlight
  // 
  public:
  struct highlight
  {
    typedef ::MovelistAnimation type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const highlight::type&
  highlight () const;

  highlight::type&
  highlight ();

  void
  highlight (const highlight::type&);

  void
  highlight (::std::auto_ptr< highlight::type >);

  // moving
  // 
  public:
  struct moving
  {
    typedef ::MovelistAnimation type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const moving::type&
  moving () const;

  moving::type&
  moving ();

  void
  moving (const moving::type&);

  void
  moving (::std::auto_ptr< moving::type >);

  // Constructors.
  //
  public:
  MovelistAnimationList (const hide_show::type&,
                         const highlight::type&,
                         const moving::type&);

  MovelistAnimationList (const ::xercesc::DOMElement&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

  MovelistAnimationList (const MovelistAnimationList&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

  virtual MovelistAnimationList*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< hide_show::type > _xsd_hide_show_;
  ::xsd::cxx::tree::one< highlight::type > _xsd_highlight_;
  ::xsd::cxx::tree::one< moving::type > _xsd_moving_;
};

class MovelistAnimation: public ::xml_schema::type
{
  public:

  struct _xsd_MovelistAnimation
  {
    typedef ::xml_schema::type base_;
  };

  // enabled
  // 
  public:
  struct enabled
  {
    typedef ::xml_schema::boolean type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;

    static const type&
    default_value ();

    private:
    static const type default_value_;
  };

  const enabled::type&
  enabled () const;

  enabled::type&
  enabled ();

  void
  enabled (const enabled::type&);

  // Constructors.
  //
  public:
  MovelistAnimation ();

  MovelistAnimation (const ::xercesc::DOMElement&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

  MovelistAnimation (const MovelistAnimation&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

  virtual MovelistAnimation*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< enabled::type > _xsd_enabled_;
};

class MovelistComments: public ::xml_schema::type
{
  public:

  struct _xsd_MovelistComments
  {
    typedef ::xml_schema::type base_;
  };

  // color
  // 
  public:
  struct color
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const color::type&
  color () const;

  color::type&
  color ();

  void
  color (const color::type&);

  void
  color (::std::auto_ptr< color::type >);

  // font
  // 
  public:
  struct font
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const font::type&
  font () const;

  font::type&
  font ();

  void
  font (const font::type&);

  void
  font (::std::auto_ptr< font::type >);

  // Constructors.
  //
  public:
  MovelistComments (const color::type&,
                    const font::type&);

  MovelistComments (const ::xercesc::DOMElement&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

  MovelistComments (const MovelistComments&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

  virtual MovelistComments*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< color::type > _xsd_color_;
  ::xsd::cxx::tree::one< font::type > _xsd_font_;
};

class VariantConfiguration: public ::xml_schema::type
{
  public:

  struct _xsd_VariantConfiguration
  {
    typedef ::xml_schema::type base_;
  };

  // variant
  // 
  public:
  struct variant
  {
    typedef ::Variant type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::sequence< type > container;
    typedef container::iterator iterator;
    typedef container::const_iterator const_iterator;
  };

  const variant::container&
  variant () const;

  variant::container&
  variant ();

  void
  variant (const variant::container&);

  // Constructors.
  //
  public:
  VariantConfiguration ();

  VariantConfiguration (const ::xercesc::DOMElement&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

  VariantConfiguration (const VariantConfiguration&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

  virtual VariantConfiguration*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::sequence< variant::type > _xsd_variant_;
};

class Variant: public ::xml_schema::type
{
  public:

  struct _xsd_Variant
  {
    typedef ::xml_schema::type base_;
  };

  // name
  // 
  public:
  struct name
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const name::type&
  name () const;

  name::type&
  name ();

  void
  name (const name::type&);

  void
  name (::std::auto_ptr< name::type >);

  // theme
  // 
  public:
  struct theme
  {
    typedef ::VariantTheme type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const theme::type&
  theme () const;

  theme::type&
  theme ();

  void
  theme (const theme::type&);

  void
  theme (::std::auto_ptr< theme::type >);

  // Constructors.
  //
  public:
  Variant (const name::type&,
           const theme::type&);

  Variant (const ::xercesc::DOMElement&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

  Variant (const Variant&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

  virtual Variant*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< name::type > _xsd_name_;
  ::xsd::cxx::tree::one< theme::type > _xsd_theme_;
};

class VariantTheme: public ::xml_schema::type
{
  public:

  struct _xsd_VariantTheme
  {
    typedef ::xml_schema::type base_;
  };

  // pieces
  // 
  public:
  struct pieces
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const pieces::type&
  pieces () const;

  pieces::type&
  pieces ();

  void
  pieces (const pieces::type&);

  void
  pieces (::std::auto_ptr< pieces::type >);

  // squares
  // 
  public:
  struct squares
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const squares::type&
  squares () const;

  squares::type&
  squares ();

  void
  squares (const squares::type&);

  void
  squares (::std::auto_ptr< squares::type >);

  // inherit-pieces
  // 
  public:
  struct inherit_pieces
  {
    typedef ::xml_schema::boolean type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;

    static const type&
    default_value ();

    private:
    static const type default_value_;
  };

  const inherit_pieces::type&
  inherit_pieces () const;

  inherit_pieces::type&
  inherit_pieces ();

  void
  inherit_pieces (const inherit_pieces::type&);

  // inherit-squares
  // 
  public:
  struct inherit_squares
  {
    typedef ::xml_schema::boolean type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;

    static const type&
    default_value ();

    private:
    static const type default_value_;
  };

  const inherit_squares::type&
  inherit_squares () const;

  inherit_squares::type&
  inherit_squares ();

  void
  inherit_squares (const inherit_squares::type&);

  // Constructors.
  //
  public:
  VariantTheme (const pieces::type&,
                const squares::type&);

  VariantTheme (const ::xercesc::DOMElement&,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

  VariantTheme (const VariantTheme&,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

  virtual VariantTheme*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< pieces::type > _xsd_pieces_;
  ::xsd::cxx::tree::one< squares::type > _xsd_squares_;
  ::xsd::cxx::tree::one< inherit_pieces::type > _xsd_inherit_pieces_;
  ::xsd::cxx::tree::one< inherit_squares::type > _xsd_inherit_squares_;
};

class AnimationConfiguration: public ::xml_schema::type
{
  public:

  struct _xsd_AnimationConfiguration
  {
    typedef ::xml_schema::type base_;
  };

  // smoothness
  // 
  public:
  struct smoothness
  {
    typedef ::xml_schema::integer type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::optional< type > container;
  };

  const smoothness::container&
  smoothness () const;

  smoothness::container&
  smoothness ();

  void
  smoothness (const smoothness::type&);

  void
  smoothness (const smoothness::container&);

  // speed
  // 
  public:
  struct speed
  {
    typedef ::xml_schema::integer type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::optional< type > container;
  };

  const speed::container&
  speed () const;

  speed::container&
  speed ();

  void
  speed (const speed::type&);

  void
  speed (const speed::container&);

  // animation-list
  // 
  public:
  struct animation_list
  {
    typedef ::AnimationList type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const animation_list::type&
  animation_list () const;

  animation_list::type&
  animation_list ();

  void
  animation_list (const animation_list::type&);

  void
  animation_list (::std::auto_ptr< animation_list::type >);

  // Constructors.
  //
  public:
  AnimationConfiguration (const animation_list::type&);

  AnimationConfiguration (const ::xercesc::DOMElement&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

  AnimationConfiguration (const AnimationConfiguration&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

  virtual AnimationConfiguration*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::optional< smoothness::type > _xsd_smoothness_;
  ::xsd::cxx::tree::optional< speed::type > _xsd_speed_;
  ::xsd::cxx::tree::one< animation_list::type > _xsd_animation_list_;
};

class AnimationList: public ::xml_schema::type
{
  public:

  struct _xsd_AnimationList
  {
    typedef ::xml_schema::type base_;
  };

  // capture
  // 
  public:
  struct capture
  {
    typedef ::Animation type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const capture::type&
  capture () const;

  capture::type&
  capture ();

  void
  capture (const capture::type&);

  void
  capture (::std::auto_ptr< capture::type >);

  // fade
  // 
  public:
  struct fade
  {
    typedef ::Animation type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const fade::type&
  fade () const;

  fade::type&
  fade ();

  void
  fade (const fade::type&);

  void
  fade (::std::auto_ptr< fade::type >);

  // movement
  // 
  public:
  struct movement
  {
    typedef ::Animation type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const movement::type&
  movement () const;

  movement::type&
  movement ();

  void
  movement (const movement::type&);

  void
  movement (::std::auto_ptr< movement::type >);

  // transform
  // 
  public:
  struct transform
  {
    typedef ::Animation type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const transform::type&
  transform () const;

  transform::type&
  transform ();

  void
  transform (const transform::type&);

  void
  transform (::std::auto_ptr< transform::type >);

  // sequence
  // 
  public:
  struct sequence
  {
    typedef ::SequenceAnimation type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const sequence::type&
  sequence () const;

  sequence::type&
  sequence ();

  void
  sequence (const sequence::type&);

  void
  sequence (::std::auto_ptr< sequence::type >);

  // Constructors.
  //
  public:
  AnimationList (const capture::type&,
                 const fade::type&,
                 const movement::type&,
                 const transform::type&,
                 const sequence::type&);

  AnimationList (const ::xercesc::DOMElement&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

  AnimationList (const AnimationList&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

  virtual AnimationList*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< capture::type > _xsd_capture_;
  ::xsd::cxx::tree::one< fade::type > _xsd_fade_;
  ::xsd::cxx::tree::one< movement::type > _xsd_movement_;
  ::xsd::cxx::tree::one< transform::type > _xsd_transform_;
  ::xsd::cxx::tree::one< sequence::type > _xsd_sequence_;
};

class Animation: public ::xml_schema::type
{
  public:

  struct _xsd_Animation
  {
    typedef ::xml_schema::type base_;
  };

  // enabled
  // 
  public:
  struct enabled
  {
    typedef ::xml_schema::boolean type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::optional< type > container;
  };

  const enabled::container&
  enabled () const;

  enabled::container&
  enabled ();

  void
  enabled (const enabled::type&);

  void
  enabled (const enabled::container&);

  // Constructors.
  //
  public:
  Animation ();

  Animation (const ::xercesc::DOMElement&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

  Animation (const Animation&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

  virtual Animation*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::optional< enabled::type > _xsd_enabled_;
};

class SequenceAnimation: public ::Animation
{
  public:

  struct _xsd_SequenceAnimation
  {
    typedef ::Animation base_;
  };

  // max
  // 
  public:
  struct max
  {
    typedef ::xml_schema::integer type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const max::type&
  max () const;

  max::type&
  max ();

  void
  max (const max::type&);

  // Constructors.
  //
  public:
  SequenceAnimation (const max::type&);

  SequenceAnimation (const ::xercesc::DOMElement&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

  SequenceAnimation (const SequenceAnimation&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

  virtual SequenceAnimation*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< max::type > _xsd_max_;
};

class EngineConfiguration: public ::xml_schema::type
{
  public:

  struct _xsd_EngineConfiguration
  {
    typedef ::xml_schema::type base_;
  };

  // default
  // 
  public:
  struct default_
  {
    typedef ::xml_schema::integer type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::optional< type > container;
  };

  const default_::container&
  default_ () const;

  default_::container&
  default_ ();

  void
  default_ (const default_::type&);

  void
  default_ (const default_::container&);

  // engine-list
  // 
  public:
  struct engine_list
  {
    typedef ::EngineList type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const engine_list::type&
  engine_list () const;

  engine_list::type&
  engine_list ();

  void
  engine_list (const engine_list::type&);

  void
  engine_list (::std::auto_ptr< engine_list::type >);

  // Constructors.
  //
  public:
  EngineConfiguration (const engine_list::type&);

  EngineConfiguration (const ::xercesc::DOMElement&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

  EngineConfiguration (const EngineConfiguration&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

  virtual EngineConfiguration*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::optional< default_::type > _xsd_default__;
  ::xsd::cxx::tree::one< engine_list::type > _xsd_engine_list_;
};

class EngineList: public ::xml_schema::type
{
  public:

  struct _xsd_EngineList
  {
    typedef ::xml_schema::type base_;
  };

  // engine
  // 
  public:
  struct engine
  {
    typedef ::Engine type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
    typedef ::xsd::cxx::tree::sequence< type > container;
    typedef container::iterator iterator;
    typedef container::const_iterator const_iterator;
  };

  const engine::container&
  engine () const;

  engine::container&
  engine ();

  void
  engine (const engine::container&);

  // Constructors.
  //
  public:
  EngineList ();

  EngineList (const ::xercesc::DOMElement&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

  EngineList (const EngineList&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

  virtual EngineList*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::sequence< engine::type > _xsd_engine_;
};

class Engine: public ::xml_schema::type
{
  public:

  struct _xsd_Engine
  {
    typedef ::xml_schema::type base_;
  };

  // Workaround for g++ bug# 23206.
  //
  public:
  struct type;

  // name
  // 
  public:
  struct name
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const name::type&
  name () const;

  name::type&
  name ();

  void
  name (const name::type&);

  void
  name (::std::auto_ptr< name::type >);

  // path
  // 
  public:
  struct path
  {
    typedef ::xml_schema::string type;
    typedef ::xsd::cxx::tree::traits< type, char > traits;
  };

  const path::type&
  path () const;

  path::type&
  path ();

  void
  path (const path::type&);

  void
  path (::std::auto_ptr< path::type >);

  // type
  // 
  public:
  struct type
  {
    typedef ::EngineType type_;
    typedef ::xsd::cxx::tree::traits< type_, char > traits;
    typedef ::xsd::cxx::tree::optional< type_ > container;
  };

  const type::container&
  type () const;

  type::container&
  type ();

  void
  type (const type::type_&);

  void
  type (const type::container&);

  void
  type (::std::auto_ptr< type::type_ >);

  // Constructors.
  //
  public:
  Engine (const name::type&,
          const path::type&);

  Engine (const ::xercesc::DOMElement&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

  Engine (const Engine&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

  virtual Engine*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  // Implementation.
  //
  private:
  void
  parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

  ::xsd::cxx::tree::one< name::type > _xsd_name_;
  ::xsd::cxx::tree::one< path::type > _xsd_path_;
  ::xsd::cxx::tree::optional< type::type_ > _xsd_type_;
};

class EngineType: public ::xml_schema::string
{
  public:
  enum _xsd_EngineType
  {
    xboard,
    UCI,
    kboard
  };

  EngineType (_xsd_EngineType);

  EngineType (const ::xml_schema::string&);

  EngineType (const ::xercesc::DOMElement&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

  EngineType (const ::xercesc::DOMAttr&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

  EngineType (const ::std::basic_string< char >&,
              const ::xercesc::DOMElement*,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

  EngineType (const EngineType&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

  virtual EngineType*
  _clone (::xml_schema::flags = 0,
          ::xml_schema::type* = 0) const;

  EngineType&
  operator= (_xsd_EngineType);

  virtual
  operator _xsd_EngineType () const
  {
    return _xsd_EngineType_convert ();
  }

  protected:
  _xsd_EngineType
  _xsd_EngineType_convert () const;

  public:
  static const char* const _xsd_EngineType_literals_[3];
  static const _xsd_EngineType _xsd_EngineType_indexes_[3];
};

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMInputSource.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <xsd/cxx/tree/parsing.hxx>

// Read from a URI or a local file.
//

::std::auto_ptr< ::Configuration >
configuration (const ::std::basic_string< char >&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

::std::auto_ptr< ::Configuration >
configuration (const ::std::basic_string< char >&,
               ::xsd::cxx::xml::error_handler< char >&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

::std::auto_ptr< ::Configuration >
configuration (const ::std::basic_string< char >&,
               ::xercesc::DOMErrorHandler&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


// Read from std::istream.
//

::std::auto_ptr< ::Configuration >
configuration (::std::istream&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

::std::auto_ptr< ::Configuration >
configuration (::std::istream&,
               ::xsd::cxx::xml::error_handler< char >&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

::std::auto_ptr< ::Configuration >
configuration (::std::istream&,
               ::xercesc::DOMErrorHandler&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


::std::auto_ptr< ::Configuration >
configuration (::std::istream&,
               const ::std::basic_string< char >& id,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

::std::auto_ptr< ::Configuration >
configuration (::std::istream&,
               const ::std::basic_string< char >& id,
               ::xsd::cxx::xml::error_handler< char >&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

::std::auto_ptr< ::Configuration >
configuration (::std::istream&,
               const ::std::basic_string< char >& id,
               ::xercesc::DOMErrorHandler&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


// Read from InputSource.
//

::std::auto_ptr< ::Configuration >
configuration (const ::xercesc::DOMInputSource&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

::std::auto_ptr< ::Configuration >
configuration (const ::xercesc::DOMInputSource&,
               ::xsd::cxx::xml::error_handler< char >&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

::std::auto_ptr< ::Configuration >
configuration (const ::xercesc::DOMInputSource&,
               ::xercesc::DOMErrorHandler&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


// Read from DOM.
//

::std::auto_ptr< ::Configuration >
configuration (const ::xercesc::DOMDocument&,
               ::xml_schema::flags = 0,
               const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


#include <iosfwd> // std::ostream&

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>
#include <xsd/cxx/tree/serialization.hxx>

void
operator<< (::xercesc::DOMElement&,
            const Configuration&);

void
operator<< (::xercesc::DOMElement&,
            const General&);

void
operator<< (::xercesc::DOMElement&,
            const BoardBorderConfiguration&);

void
operator<< (::xercesc::DOMElement&,
            const IcsConfiguration&);

void
operator<< (::xercesc::DOMElement&,
            const Timeseal&);

void
operator<< (::xercesc::DOMElement&,
            const TimesealCommand&);

void
operator<< (::xercesc::DOMElement&,
            const ClockConfiguration&);

void
operator<< (::xercesc::DOMElement&,
            const ClockElement&);

void
operator<< (::xercesc::DOMElement&,
            const HighlightingConfiguration&);

void
operator<< (::xercesc::DOMElement&,
            const LuaHLConfiguration&);

void
operator<< (::xercesc::DOMElement&,
            const ScriptList&);

void
operator<< (::xercesc::DOMElement&,
            const SimpleHighlighting&);

void
operator<< (::xercesc::DOMElement&,
            const HighlightingPattern&);

void
operator<< (::xercesc::DOMElement&,
            const HighlightingFormat&);

void
operator<< (::xercesc::DOMElement&,
            const MovelistConfiguration&);

void
operator<< (::xercesc::DOMElement&,
            const MovelistAnimationConfiguration&);

void
operator<< (::xercesc::DOMElement&,
            const MovelistAnimationList&);

void
operator<< (::xercesc::DOMElement&,
            const MovelistAnimation&);

void
operator<< (::xercesc::DOMElement&,
            const MovelistComments&);

void
operator<< (::xercesc::DOMElement&,
            const VariantConfiguration&);

void
operator<< (::xercesc::DOMElement&,
            const Variant&);

void
operator<< (::xercesc::DOMElement&,
            const VariantTheme&);

void
operator<< (::xercesc::DOMElement&,
            const AnimationConfiguration&);

void
operator<< (::xercesc::DOMElement&,
            const AnimationList&);

void
operator<< (::xercesc::DOMElement&,
            const Animation&);

void
operator<< (::xercesc::DOMElement&,
            const SequenceAnimation&);

void
operator<< (::xercesc::DOMElement&,
            const EngineConfiguration&);

void
operator<< (::xercesc::DOMElement&,
            const EngineList&);

void
operator<< (::xercesc::DOMElement&,
            const Engine&);

void
operator<< (::xercesc::DOMElement&,
            EngineType);

void
operator<< (::xercesc::DOMAttr&,
            EngineType);

void
operator<< (::xsd::cxx::tree::list_stream< char >&,
            EngineType);

// Serialize to an existing DOM instance.
//
void
configuration (::xercesc::DOMDocument&,
               const ::Configuration&,
               ::xml_schema::flags = 0);


// Serialize to a new DOM instance.
//
::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
configuration (const ::Configuration&, 
               const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
               ::xml_schema::flags = 0);


// Serialize to XMLFormatTarget.
//
void
configuration (::xercesc::XMLFormatTarget&,
               const ::Configuration&, 
               const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
               const ::std::basic_string< char >& = "UTF-8",
               ::xml_schema::flags = 0);


void
configuration (::xercesc::XMLFormatTarget&,
               const ::Configuration&, 
               const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
               ::xsd::cxx::xml::error_handler< char >&,
               const ::std::basic_string< char >& = "UTF-8",
               ::xml_schema::flags = 0);

void
configuration (::xercesc::XMLFormatTarget&,
               const ::Configuration&, 
               const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
               ::xercesc::DOMErrorHandler&,
               const ::std::basic_string< char >& = "UTF-8",
               ::xml_schema::flags = 0);


// Serialize to std::ostream.
//
void
configuration (::std::ostream&,
               const ::Configuration&, 
               const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
               const ::std::basic_string< char >& = "UTF-8",
               ::xml_schema::flags = 0);


void
configuration (::std::ostream&,
               const ::Configuration&, 
               const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
               ::xsd::cxx::xml::error_handler< char >&,
               const ::std::basic_string< char >& = "UTF-8",
               ::xml_schema::flags = 0);

void
configuration (::std::ostream&,
               const ::Configuration&, 
               const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
               ::xercesc::DOMErrorHandler&,
               const ::std::basic_string< char >& = "UTF-8",
               ::xml_schema::flags = 0);


#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CONFIG_HXX
